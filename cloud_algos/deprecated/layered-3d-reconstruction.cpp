
/// scene b ///

/// layers-struct data/b-1224513478-dsn-objects.pcd -line_thresh 0.0050 -circle_thresh 0.0050 -density_thresh 0.040 -min_nr_nn 20 -ang_thresh  30.0 -min_reg_size 15 -min_reg_bound_size 5-negative_thresh 0.0125 -min_inliers_line 10 -min_inliers_circle 10 -region_step 0 -model_step 1 -shape_step 0 -line_merging_thresh 45.0 -rectanguloid_approximation 0.040 -neg_per_thresh 0.40 -boundary_thresh 0.75-cam "1.32246,3.73036/1.36111,0.385237,0.715423/-0.557441,-0.377583,1.93646/0.456053,0.229389,0.859882" -height_of_layer 0.020 -connectivity_thresh 0.025

/// layers-struct data/b-1224513478-dsn-objects.pcd -line_thresh 0.0050 -circle_thresh 0.0050 -density_thresh 0.040 -min_nr_nn 20 -ang_thresh  30.0 -min_reg_size 15 -min_reg_bound_size 5-negative_thresh 0.0125 -min_inliers_line 10 -min_inliers_circle 20 -region_step 0 -model_step 1 -shape_step 0 -line_merging_thresh 45.0 -rectanguloid_approximation 0.040 -neg_per_thresh 0.40 -boundary_thresh 0.00-cam "1.32246,3.73036/1.36111,0.385237,0.715423/-0.557441,-0.377583,1.93646/0.456053,0.229389,0.859882" -height_of_layer 0.040 -connectivity_thresh 0.015

/// layers-struct data/b-1224513478-dsn-objects.pcd -line_thresh 0.0050 -circle_thresh 0.0050 -density_thresh 0.040 -min_nr_nn 20 -ang_thresh  30.0 -min_reg_size 15 -min_reg_bound_size 5-negative_thresh 0.0125 -min_inliers_line 10 -min_inliers_circle 20 -region_step 0 -model_step 1 -shape_step 0 -line_merging_thresh 45.0 -rectanguloid_approximation 0.045 -neg_per_thresh 0.40 -boundary_thresh 0.55-cam "1.32246,3.73036/1.36111,0.385237,0.715423/-0.557441,-0.377583,1.93646/0.456053,0.229389,0.859882" -height_of_layer 0.060 -connectivity_thresh 0.020

/// layers-struct data/b-1224513478-dsn-objects.pcd -line_thresh 0.0050 -circle_thresh 0.0050 -density_thresh 0.040 -min_nr_nn 20 -ang_thresh  30.0 -min_reg_size 30 -min_reg_bound_size 5-negative_thresh 0.0125 -min_inliers_line 10 -min_inliers_circle 20 -region_step 0 -model_step 1 -shape_step 0 -line_merging_thresh 45.0 -rectanguloid_approximation 0.050 -neg_per_thresh 0.40 -boundary_thresh 0.75-cam "1.32246,3.73036/1.36111,0.385237,0.715423/-0.557441,-0.377583,1.93646/0.456053,0.229389,0.859882" -height_of_layer 0.080 -connectivity_thresh 0.010

/// layers-struct data/b-1224513478-dsn-objects.pcd -line_thresh 0.0075 -circle_thresh 0.0075 -density_thresh 0.040 -min_nr_nn 20 -ang_thresh  30.0 -min_reg_size 30 -min_reg_bound_size 5-negative_thresh 0.0125 -min_inliers_line 10 -min_inliers_circle 20 -region_step 0 -model_step 1 -shape_step 0 -line_merging_thresh 45.0 -rectanguloid_approximation 0.050 -neg_per_thresh 0.40 -boundary_thresh 0.75-cam "1.32246,3.73036/1.36111,0.385237,0.715423/-0.557441,-0.377583,1.93646/0.456053,0.229389,0.859882" -height_of_layer 0.100 -connectivity_thresh 0.015

/// scene c ///

/// layers-struct data/c-1224513681-dsn-objects.pcd -line_thresh 0.0050 -circle_thresh 0.0050 -density_thresh 0.040 -min_nr_nn 20 -ang_thresh  45.0 -min_reg_size 15 -min_reg_bound_size 5-negative_thresh 0.0125 -min_inliers_line  5 -min_inliers_circle 20 -region_step 0 -model_step 1 -shape_step 0 -line_merging_thresh 45.0 -rectanguloid_approximation 0.000 -neg_per_thresh 0.40 -boundary_thresh 0.75-cam "1.3234,4.0128/1.36111,0.385237,0.715423/-0.275099,-0.862575,1.94808/0.416162,0.301675,0.857789" -height_of_layer 0.020 -connectivity_thresh 0.015

/// layers-struct data/c-1224513681-dsn-objects.pcd -line_thresh 0.0075 -circle_thresh 0.0075 -density_thresh 0.040 -min_nr_nn 20 -ang_thresh  45.0 -min_reg_size 15 -min_reg_bound_size 5-negative_thresh 0.0125 -min_inliers_line 10 -min_inliers_circle 20 -region_step 0 -model_step 1 -shape_step 0 -line_merging_thresh 45.0 -rectanguloid_approximation 0.000 -neg_per_thresh 0.40 -boundary_thresh 0.75-cam "1.3234,4.0128/1.36111,0.385237,0.715423/-0.275099,-0.862575,1.94808/0.416162,0.301675,0.857789" -height_of_layer 0.040 -connectivity_thresh 0.015

/// layers-struct data/c-1224513681-dsn-objects.pcd -line_thresh 0.0075 -circle_thresh 0.0075 -density_thresh 0.040 -min_nr_nn 20 -ang_thresh  45.0 -min_reg_size 15 -min_reg_bound_size 5-negative_thresh 0.0125 -min_inliers_line 10 -min_inliers_circle 20 -region_step 0 -model_step 1 -shape_step 0 -line_merging_thresh 45.0 -rectanguloid_approximation 0.000 -neg_per_thresh 0.40 -boundary_thresh 0.75-cam "1.3234,4.0128/1.36111,0.385237,0.715423/-0.275099,-0.862575,1.94808/0.416162,0.301675,0.857789" -height_of_layer 0.060 -connectivity_thresh 0.015

/// layers-struct data/c-1224513681-dsn-objects.pcd -line_thresh 0.0075 -circle_thresh 0.0075 -density_thresh 0.040 -min_nr_nn 20 -ang_thresh  45.0 -min_reg_size 15 -min_reg_bound_size 5-negative_thresh 0.0125 -min_inliers_line 10 -min_inliers_circle 20 -region_step 0 -model_step 1 -shape_step 0 -line_merging_thresh 45.0 -rectanguloid_approximation 0.000 -neg_per_thresh 0.40 -boundary_thresh 0.75-cam "1.3234,4.0128/1.36111,0.385237,0.715423/-0.275099,-0.862575,1.94808/0.416162,0.301675,0.857789" -height_of_layer 0.080 -connectivity_thresh 0.010

/// layers-struct data/c-1224513681-dsn-objects.pcd -line_thresh 0.0075 -circle_thresh 0.0075 -density_thresh 0.040 -min_nr_nn 20 -ang_thresh  45.0 -min_reg_size 15 -min_reg_bound_size 5-negative_thresh 0.0125 -min_inliers_line 10 -min_inliers_circle 20 -region_step 0 -model_step 1 -shape_step 0 -line_merging_thresh 45.0 -rectanguloid_approximation 0.000 -neg_per_thresh 0.40 -boundary_thresh 0.75-cam "1.3234,4.0128/1.36111,0.385237,0.715423/-0.275099,-0.862575,1.94808/0.416162,0.301675,0.857789" -height_of_layer 0.100 -connectivity_thresh 0.010

/// scene d ///

/// layers-struct data/d-1224512906-dsn-objects.pcd -line_thresh 0.0075 -circle_thresh 0.0075 -density_thresh 0.040 -min_nr_nn 20 -ang_thresh  75.0 -min_reg_size 15 -min_reg_bound_size 5-negative_thresh 0.0125 -min_inliers_line  5 -min_inliers_circle 10 -region_step 0 -model_step 0 -shape_step 0 -line_merging_thresh 45.0 -rectanguloid_approximation 0.000 -neg_per_thresh 0.40 -boundary_thresh 0.80-cam "1.27389,3.53469/1.28425,0.386347,0.86246/-0.655388,-0.0511804,1.96244/0.468357,0.123261,0.874899" -height_of_layer 0.020 -connectivity_thresh 0.010

/// layers-struct data/d-1224512906-dsn-objects.pcd -line_thresh 0.0050 -circle_thresh 0.0050 -density_thresh 0.040 -min_nr_nn 20 -ang_thresh  45.0 -min_reg_size 15 -min_reg_bound_size 5-negative_thresh 0.0125 -min_inliers_line 10 -min_inliers_circle 20 -region_step 0 -model_step 1 -shape_step 0 -line_merging_thresh 45.0 -rectanguloid_approximation 0.000 -neg_per_thresh 0.40 -boundary_thresh 0.80-cam "1.27389,3.53469/1.28425,0.386347,0.86246/-0.655388,-0.0511804,1.96244/0.468357,0.123261,0.874899" -height_of_layer 0.040 -connectivity_thresh 0.010

/// layers-struct data/d-1224512906-dsn-objects.pcd -line_thresh 0.0050 -circle_thresh 0.0050 -density_thresh 0.040 -min_nr_nn 20 -ang_thresh  45.0 -min_reg_size 15 -min_reg_bound_size 5-negative_thresh 0.0125 -min_inliers_line 10 -min_inliers_circle 20 -region_step 0 -model_step 1 -shape_step 0 -line_merging_thresh 45.0 -rectanguloid_approximation 0.000 -neg_per_thresh 0.40 -boundary_thresh 0.80-cam "1.27389,3.53469/1.28425,0.386347,0.86246/-0.655388,-0.0511804,1.96244/0.468357,0.123261,0.874899" -height_of_layer 0.060 -connectivity_thresh 0.010

/// layers-struct data/d-1224512906-dsn-objects.pcd -line_thresh 0.0075 -circle_thresh 0.0075 -density_thresh 0.040 -min_nr_nn 20 -ang_thresh  45.0 -min_reg_size 15 -min_reg_bound_size 5-negative_thresh 0.0125 -min_inliers_line 10 -min_inliers_circle 20 -region_step 0 -model_step 1 -shape_step 0 -line_merging_thresh 45.0 -rectanguloid_approximation 0.000 -neg_per_thresh 0.40 -boundary_thresh 0.80-cam "1.27389,3.53469/1.28425,0.386347,0.86246/-0.655388,-0.0511804,1.96244/0.468357,0.123261,0.874899" -height_of_layer 0.080 -connectivity_thresh 0.010

/// layers-struct data/d-1224512906-dsn-objects.pcd -line_thresh 0.0100 -circle_thresh 0.0100 -density_thresh 0.040 -min_nr_nn 20 -ang_thresh  45.0 -min_reg_size 15 -min_reg_bound_size 5-negative_thresh 0.0125 -min_inliers_line  5 -min_inliers_circle 20 -region_step 0 -model_step 1 -shape_step 0 -line_merging_thresh 45.0 -rectanguloid_approximation 0.000 -neg_per_thresh 0.40 -boundary_thresh 0.80-cam "1.27389,3.53469/1.28425,0.386347,0.86246/-0.655388,-0.0511804,1.96244/0.468357,0.123261,0.874899" -height_of_layer 0.100 -connectivity_thresh 0.010



#include "../common/CommonANNRoutines.h"
#include "../common/VTKShapes.h"
#include <vtkRegularPolygonSource.h>
#include <vtkCylinderSource.h>
#include <vtkRotationFilter.h>
#include <vtkTubeFilter.h>

using namespace cANN;
using namespace std;

struct shape
{
  int type;
  ANNpoint model;
  vector<int> inliers;
};

double line_thresh = 0.0100;
double circle_thresh = 0.0100;
double connectivity_thresh = 0.010; /// [mm]
double ang_thresh = 90; /// [degrees]
double density_thresh = 0.020; /// [mm]
double thickness_thresh = 0.0075; /// [mm]
// double angle_merging_thresh = 10.0; /// [degrees]
double line_merging_thresh = 15.0; /// [degrees]
double boundary_thresh = 0.75; /// [%]

int min_nr_nn =   25; /// [points]
int max_nr_nn = 2500; /// [points]
double min_rad = 0.020; /// [mm]
double max_rad = 0.200; /// [mm]

int min_reg_size = 40; /// [points]
int min_reg_bound_size = 5; /// [points]
int min_inliers_line = 10; /// [points]
int min_inliers_circle = 30; /// [points]

int point_size = 4;
double res = 0.005; /// [mm]
double res_ang = 2.0; /// [degees]
double negative_thresh = 0.010; /// [mm]
double occlusion_thresh = 0.040; /// [mm]

double rectanguloid_approximation = 0.05; /// [%]
double neg_per_thresh = 0.0; /// [%]

bool region_step = false;
bool  model_step = false;
bool  shape_step = false;

double opacity = 0.25; /// [%]

double height_of_layer = 0.050;  /// [cm]



/// CREATE ANN POINTS FROM INDICES OF ONE LAYER ///
ANNpointArray doPointsOfIndices (ANNpointArray points, int nr_points, vector<int> indices)
{
  ANNpointArray points_of_layer = annAllocPts (nr_points, 3, 0.0);
  
  for (int i = 0 ; i < (int)indices.size() ; i++)
  {
    points_of_layer [indices[i]] [0] = points [indices[i]] [0];
    points_of_layer [indices[i]] [1] = points [indices[i]] [1];
    points_of_layer [indices[i]] [2] = points [indices[i]] [2];
  }
  
  return points_of_layer;
}

/// Compute Principle Component Analisys ///
void computeNormalCurvatureNoAllocWithEig (ANNpointArray points, int dim, vector<int> &indices, ANNpoint &nc, ANNpoint &eVal, ANNpointArray &eVec, ANNpoint &centroid)
{
  
  ANNpointArray cov_matrix = computeCovarianceMatrix (points, dim, indices, centroid);

  eig_sym (cov_matrix, eVal, eVec, dim);
    
  double nlen = 0.0;
  for (int d = 0 ; d < dim ; d++ )
    nlen = nlen + _sqr(eVec[0][d]);
  
  for (int d = 0 ; d < dim ; d++ )
    nc[d] = eVec[0][d] / nlen;
}

/// FITTING LINES ///
vector<int> getSamplesLine (ANNpointArray points, vector<int> &region)
{
  vector<int> random_idx(2);
  do 
  {
    for (int i = 0; i < 2; i++)
    {
      random_idx[i] = region[ (int)((int)region.size() * (rand() / (RAND_MAX + 1.0))) ];
    }
  } while (random_idx[0] == random_idx[1]);
  
  return random_idx;
}

vector<int> getInliersLine (ANNpointArray points, vector<int> &region, vector<int> &samples)
{
  double x1 = points[samples[0]][0];
  double y1 = points[samples[0]][1];
  double x2 = points[samples[1]][0];
  double y2 = points[samples[1]][1];
  
  vector<int> inliers;
  for (int i = 0; i < (int)region.size(); i++)
  {
    double x0 = points[region[i]][0];  
    double y0 = points[region[i]][1];
    
    double d = fabs( (x2-x1)*(y1-y0) - (x1-x0)*(y2-y1) ) / sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) );    
    
    if (fabs(d) < line_thresh) 
      inliers.push_back(region[i]);
  }
  
  return inliers;
}

int fitLine (ANNpointArray points, vector<int> &region, vector<int> &best_inliers, vector<int> &best_samples, double max_iterations, bool verbose=false)
{
  int iterations = 0;
  double wlan, p = 0.99999, k = max_iterations;
  
  do
  {
    iterations++;
    vector<int> samples = getSamplesLine (points, region);
    vector<int> inliers = getInliersLine (points, region, samples);
    if (inliers.size() > best_inliers.size())
    {
      best_inliers = inliers;
      best_samples = samples;
      wlan = pow( (double)inliers.size() / (double)region.size() , (double)samples.size() );
      k = log(1 - p) / log(1 - wlan);
      if (verbose) fprintf(stderr, "         At iteration %4d number of inliers %4d is bigger then the best. Number of interations: %4d \n", iterations, (int)inliers.size(), (int)k);
    }
  } while ( (iterations < max_iterations) && (iterations < k) );
  
  return iterations;
}

void computeLineLengthwise (ANNpointArray points, vector<int> &inliers, double &x1, double &y1, double &x2, double &y2)
{
  /// compute line vector ///
  double l[3];
  l[0] = x2 - x1;
  l[1] = y2 - y1;
  /// normalize line vector ///
  double nl = sqrt ( _sqr(l[0]) + _sqr(l[1]) );
  l[0] = l[0] / nl;
  l[1] = l[1] / nl;
  
  /// get lenghtwise limits of inliers ///
  double minDistLW =  DBL_MAX;
  double maxDistLW = -DBL_MAX;
  for ( int idx=0 ; idx < (int)inliers.size() ; idx++ )
  {
    double p[2];
    p[0] = points [inliers[idx]] [0] - x1;
    p[1] = points [inliers[idx]] [1] - y1;
    
    double DistLW = (l[0] * p[0]) + (l[1] * p[1]);
    if ( minDistLW > DistLW )  minDistLW = DistLW;
    if ( maxDistLW < DistLW )  maxDistLW = DistLW;
  }
  
  /// compute new model of line ///
  x2 = x1 + l[0]*maxDistLW;
  y2 = y1 + l[1]*maxDistLW;
  
  x1 = x1 + l[0]*minDistLW;
  y1 = y1 + l[1]*minDistLW;
}

void printLine (double x1, double y1, double z1, double x2, double y2, double z2, vtkRenderer* ren, vtkRenderWindowInteractor* iren, double R, double G, double B, bool step=false)
{
  vtkLineSource* line = vtkLineSource::New();
  line->SetPoint1 (x1, y1, z1);
  line->SetPoint2 (x2, y2, z2);
  
  vtkTubeFilter* tube = vtkTubeFilter::New();
  tube->SetInput (line->GetOutput());
  tube->SetNumberOfSides (99);
  tube->SetRadius (0.002);
  
  vtkActor* lineActor = createActorFromDataSet (line->GetOutput(), false);
  lineActor->GetProperty()->SetColor (R, G, B);
  ren->AddActor (lineActor);
  
  vtkActor* tubeActor = createActorFromDataSet (tube->GetOutput(), false);
  tubeActor->GetProperty()->SetColor (R, G, B);
  ren->AddActor (tubeActor);
    
  if ( step )
  {
    iren->Render();
    iren->Start();
  }
}

/// FITTING CIRCLES ///
double RegionLimit (ANNpointArray points, vector<int> &region_boundary_points)
{
  ANNpoint centroid = annAllocPt(2);
  ANNpoint eVal = NULL;
  ANNpointArray eVec = NULL;
  ANNpoint normal = annAllocPt (2);
  computeCentroidNoAlloc (points, 2, region_boundary_points , centroid);
  computeNormalCurvatureNoAllocWithEig (points, 2, region_boundary_points, normal, eVal, eVec, centroid);
  
  double max_u = -DBL_MAX;
  double min_u =  DBL_MAX;
  double max_v = -DBL_MAX;
  double min_v =  DBL_MAX;
  
  for(int m = 0; m < (int)region_boundary_points.size(); m++)
  {
    ANNcoord c2p[3];
    c2p[0] = points[region_boundary_points[m]][0] - centroid[0];
    c2p[1] = points[region_boundary_points[m]][1] - centroid[1];
    c2p[2] = points[region_boundary_points[m]][2] - centroid[2];
    
    double  width = eVec[0][0]*c2p[0] + eVec[0][1]*c2p[1];
    if (width > max_v) max_v = width;
    if (width < min_v) min_v = width;
    double height = eVec[1][0]*c2p[0] + eVec[1][1]*c2p[1];
    if (height > max_u) max_u = height;
    if (height < min_u) min_u = height;
  }
  
  double Xmax = centroid[0] + eVec[1][0]*max_u + eVec[0][0]*max_v;
  double Ymax = centroid[1] + eVec[1][1]*max_u + eVec[0][1]*max_v;
  double Xmin = centroid[0] + eVec[1][0]*min_u + eVec[0][0]*min_v;
  double Ymin = centroid[1] + eVec[1][1]*min_u + eVec[0][1]*min_v;
  
  double diag = sqrt( (Xmax-Xmin)*(Xmax-Xmin) + (Ymax-Ymin)*(Ymax-Ymin) );
  
  return diag / 2;
}

vector<int> getSamplesCircle (ANNpointArray points, vector<int> &region)
{
  vector<int> random_idx(3);
  do 
  {
    for (int i = 0; i < 3; i++)
    {
      random_idx[i] = region[ (int)((int)region.size() * (rand() / (RAND_MAX + 1.0))) ];
    }
  } while ( (random_idx[0] == random_idx[1]) || (random_idx[0] == random_idx[2]) || (random_idx[1] == random_idx[2]) );
  
  return random_idx;
}

vector<int> getInliersCircle (ANNpointArray points, vector<int> &region, vector<int> &samples, double max_r, ANNpoint &c, double &r)
{
  double x1 = points[samples[0]][0]; 
  double y1 = points[samples[0]][1];
  double x2 = points[samples[1]][0]; 
  double y2 = points[samples[1]][1];
  double x3 = points[samples[2]][0]; 
  double y3 = points[samples[2]][1];
  
  double ma = (y2 - y1) / (x2 - x1);
  double mb = (y3 - y2) / (x3 - x2);
  
  c[0] = (ma*mb*(y1-y3) + mb*(x1+x2) - ma*(x2+x3)) / (2*(mb - ma));
  c[1] = -(1/ma)*(c[0] - (x1+x2)/2) + (y1+y2)/2;
  r = sqrt((c[0]-x1)*(c[0]-x1) + (c[1]-y1)*(c[1]-y1));
  
  vector<int> inliers; 
  if ( (min_rad < r) && (r < max_r) )
  {
    for (int i = 0; i < (int)region.size(); i++)
    {
      double x0 = points[region[i]][0];  
      double y0 = points[region[i]][1];    
      double d = sqrt((x0-c[0])*(x0-c[0]) + (y0-c[1])*(y0-c[1])) - r;    
      if (fabs(d) < circle_thresh) inliers.push_back(region[i]);
    }
  }
  
  return inliers;
}

int fitCircle (ANNpointArray points, vector<int> &region, vector<int> &best_inliers, vector<int> &best_samples, double max_iterations, double max_r, ANNpoint &best_c, double &best_r, bool verbose=false)
{
  int iterations = 0;
  double wlan, p = 0.99999, k = max_iterations;
  ANNpoint c = annAllocPt (2);
  double r;
  
  do
  {
    iterations++;
    vector<int> samples = getSamplesCircle (points, region);
    vector<int> inliers = getInliersCircle (points, region, samples, max_r, c, r);
    if (inliers.size() > best_inliers.size())
    {
      best_inliers = inliers;
      best_samples = samples;
      best_c[0] = c[0];
      best_c[1] = c[1];
      best_r = r;
      wlan = pow( (double)inliers.size() / (double)region.size() , (double)samples.size() );
      k = log(1 - p) / log(1 - wlan);
      if (verbose) fprintf(stderr, "         At iteration %4d number of inliers %4d is bigger then the best. Number of interations: %4d \n", iterations, (int)inliers.size(), (int)k);
    } 
  } while ( (iterations < max_iterations) && (iterations < k) );
  
  return iterations;
}

void getInliersDisk (ANNpointArray points, vector<int> &region, vector<int> &inliers, ANNpoint c, double r)
{
  for (int idx=0 ; idx < (int)region.size(); idx++)
  {
    double x0 = points [region[idx]] [0];  
    double y0 = points [region[idx]] [1];
    double d = sqrt( (c[0]-x0)*(c[0]-x0) + (c[1]-y0)*(c[1]-y0) );
    if ( d < r ) inliers.push_back (region[idx]);
  }
  
  sort (inliers.begin(), inliers.end());
  inliers.erase (unique (inliers.begin(), inliers.end()), inliers.end());
}

void printCircle (double cx, double cy, double cz, double r, vtkRenderer* ren, vtkRenderWindowInteractor* iren, double R, double G, double B, bool step=false)
{
  vtkRegularPolygonSource* circle = vtkRegularPolygonSource::New();
  circle->SetCenter(cx, cy, cz);
  circle->SetRadius(r);
  circle->SetNumberOfSides(99);
  
  vtkTubeFilter* tube = vtkTubeFilter::New();
  tube->SetInput (circle->GetOutput());
  tube->SetNumberOfSides (99);
  tube->SetRadius (0.002);
  
  vtkActor* circleActor = createActorFromDataSet (circle->GetOutput(), false);
  circleActor->GetProperty()->SetRepresentationToWireframe();
  circleActor->GetProperty()->SetColor(R, G, B);
  ren->AddActor (circleActor);
  
  vtkActor* tubeActor = createActorFromDataSet (tube->GetOutput(), false);
  tubeActor->GetProperty()->SetColor (R, G, B);
  ren->AddActor (tubeActor);
  
  if ( step )
  {
    iren->Render();
    iren->Start();
  }
}

/// Compute Dense Points ///  
vector<int> getDensePoints (ANNpointArray points, int nr_points, int kIdx, ANNkd_tree* kd_tree, double sqr_density_thresh, vtkRenderer* ren, vtkRenderWindowInteractor* iren, bool verbose=false)
{
  int k;
  vector<int> vector_of_indices;
  for (int pt = 0 ; pt < nr_points ; pt++)
  {
    k = kd_tree->annkFRSearch (points[pt], sqr_density_thresh, 0, NULL, NULL, 0.0);
    points[pt][kIdx] = k;
    if ( k >= min_nr_nn )
      vector_of_indices.push_back(pt);
  }
  
  if ( verbose )
  {
    ren->AddActor (createActorFromDataSet (ANNToVTK(points, vector_of_indices), 0.5, 0.5, 0.5, point_size, false)); // color gray dense points
    iren->Render();
    iren->Start ();
  }
  
  return vector_of_indices;
}

/// Compute Boundary Points ///
bool isBoundaryPoint2D (ANNpoint query_pt, ANNpointArray points, vector<int> &indices, double threshold)
{
  vector<double> angles;
  ANNpoint uvn_nn = annAllocPt (2);
  
  // Compute the angles between each neighbouring point and the query point itself
  for (unsigned i = 0; i < indices.size(); i++)
  {
    // Centering coodinates around query_pt
    uvn_nn[0] = points[indices[i]][0] - query_pt[0];
    uvn_nn[1] = points[indices[i]][1] - query_pt[1];
    // Computing the real angle in the [ 0, 2*PI ) interval
    if ((uvn_nn[0] != 0.0) || (uvn_nn[1] != 0.0))
      angles.push_back (getAngle2D (uvn_nn));
  }
    
  // Sorting angles
  sort (angles.begin (), angles.end ());

  // Compute the maximal angle difference between two consecutive angles
  double dif, max_dif = -DBL_MAX;
  for (unsigned i = 0 ; i < angles.size()-1 ; i++)
  {
    dif = angles[i+1] - angles[i];
    if (max_dif < dif)
      max_dif = dif;
  }
  
  // Get the angle difference between the last and the first
  dif = 2*M_PI - angles[angles.size()-1] + angles[0];
  if (max_dif < dif)
    max_dif = dif;
    
  // If the maximum angle difference is bigger than our threshold
  if (max_dif > threshold)
    return (true);
  else
    return (false);
}

vector<vector<int> > computeBoundaries (ANNpointArray points, vector<vector<int> > &regions, double ang_thresh, vtkRenderer* ren, vtkRenderWindowInteractor* iren, bool verbose=false)
{
  vector<vector<int> > boundaries (regions.size());
  
  for ( int reg = 0; reg < (int)regions.size() ; reg++ )
  {
    for ( int idx = 0 ; idx < (int)regions[reg].size(); idx++ )
    {
      if ( isBoundaryPoint2D (points[regions[reg][idx]], points, regions[reg], ang_thresh) )
        boundaries[reg].push_back (regions[reg][idx]);
    }
  }
  
  if ( verbose ) 
  {
    for (int reg = 0 ; reg < (int)boundaries.size() ; reg++ )
      ren->AddActor (createActorFromDataSet (ANNToVTK(points, boundaries[reg]), 0.0, 1.0, 1.0, point_size, false));
    
    iren->Render();
    iren->Start ();
  }
  
  return boundaries;
}

/// Compute Thickness for Boundary Points ///
vector<vector<int> > computeThickBoundaries (ANNpointArray points, vector<vector<int> > &regions, vector<vector<int> > &boundaries, int kIdx, ANNkd_tree* kd_tree, ANNidxArray nnIdx, ANNdistArray sqrDists,
                                             double sqr_thickness_thresh, vtkRenderer* ren, vtkRenderWindowInteractor* iren, bool verbose=false)
{
  vector<vector<int> > thick_boundaries (boundaries.size());
  
  for ( int reg = 0 ; reg < (int)boundaries.size(); reg++ )
  {
    for ( int idx = 0; idx < (int)boundaries[reg].size(); idx++ )
    {
      int k = kd_tree->annkFRSearch (points [boundaries[reg][idx]], sqr_thickness_thresh, 0, NULL, NULL, 0.0);
      kd_tree->annkFRSearch (points [boundaries[reg][idx]], sqr_thickness_thresh, k, nnIdx, sqrDists, 0.0);
      for ( int nn = 0 ; nn < k ; nn++ )
        if ( points [nnIdx[nn]] [kIdx] >= min_nr_nn )
          thick_boundaries[reg].push_back (nnIdx[nn]);
    }
    
    sort (thick_boundaries[reg].begin(), thick_boundaries[reg].end());
    thick_boundaries[reg].erase ( unique (thick_boundaries[reg].begin(), thick_boundaries[reg].end()), thick_boundaries[reg].end());
  }
  
  if ( verbose )
  {
    for (int reg = 0 ; reg < (int)thick_boundaries.size() ; reg++ )
      ren->AddActor (createActorFromDataSet (ANNToVTK (points, thick_boundaries[reg]), 0.0, 1.0, 1.0, point_size, false));
    iren->Render();
    iren->Start();
  }

  return thick_boundaries;
}

vector<int> computeBoundariesOfLayer (ANNpointArray points, ANNpointArray points_of_layer, vector<int> &regions, double ang_thresh, vtkRenderer* ren, vtkRenderWindowInteractor* iren, bool verbose=false)
{
  vector<int> boundaries;
  
  for ( int idx = 0 ; idx < (int)regions.size(); idx++ )
  {
    if ( isBoundaryPoint2D (points[regions[idx]], points_of_layer, regions, ang_thresh) )
      boundaries.push_back (regions[idx]);
  }
  
  if ( verbose ) 
  {
    ren->AddActor (createActorFromDataSet (ANNToVTK(points, boundaries), 0.0, 1.0, 1.0, point_size, false));
    
    iren->Render();
    iren->Start ();
  }
  
  return boundaries;
}

/// Compute Thickness for Boundary Points ///
vector<int> computeThickBoundariesOfLayer (ANNpointArray points, ANNpointArray points_of_layer, vector<int> &boundaries, int kIdx, ANNkd_tree* kd_tree, ANNidxArray nnIdx, ANNdistArray sqrDists,
                                           double sqr_thickness_thresh, vtkRenderer* ren, vtkRenderWindowInteractor* iren, bool verbose=false)
{
  vector<int> thick_boundaries;
  
  for ( int idx = 0; idx < (int)boundaries.size(); idx++ )
  {
    int k = kd_tree->annkFRSearch (points [boundaries[idx]], sqr_thickness_thresh, 0, NULL, NULL, 0.0);
    kd_tree->annkFRSearch (points [boundaries[idx]], sqr_thickness_thresh, k, nnIdx, sqrDists, 0.0);
    for ( int nn = 0 ; nn < k ; nn++ )
      if ( points [nnIdx[nn]] [kIdx] >= min_nr_nn )
        thick_boundaries.push_back (nnIdx[nn]);
  }
  
  sort (thick_boundaries.begin(), thick_boundaries.end());
  thick_boundaries.erase ( unique (thick_boundaries.begin(), thick_boundaries.end()), thick_boundaries.end());
  
  if ( verbose )
  {
    ren->AddActor (createActorFromDataSet (ANNToVTK (points, thick_boundaries), 0.0, 1.0, 1.0, point_size, false));
    
    iren->Render();
    iren->Start();
  }

  return thick_boundaries;
}

void smallestRectangle (ANNpointArray points, vector<vector<int> > &regions, vtkRenderer* ren, vtkRenderWindowInteractor* iren, bool verbose=false)
{
  for ( int reg=0 ; reg < (int)regions.size() ; reg++ )
  {
    double minX =  DBL_MAX;
    double minY =  DBL_MAX;
    double maxX = -DBL_MAX;
    double maxY = -DBL_MAX;
    
    for ( int idx=0 ; idx < (int)regions[reg].size() ; idx++ )
    {
      if ( minX > points [regions[reg][idx]] [0] )  minX = points [regions[reg][idx]] [0];
      if ( minY > points [regions[reg][idx]] [1] )  minY = points [regions[reg][idx]] [1];
      if ( maxX < points [regions[reg][idx]] [0] )  maxX = points [regions[reg][idx]] [0];
      if ( maxY < points [regions[reg][idx]] [1] )  maxY = points [regions[reg][idx]] [1];
    }
    
    if ( verbose )
    {
      /// Print Smallest Rectangle ///
      double minZ = DBL_MAX;
      for ( int idx = 0 ; idx < (int)regions[reg].size() ; idx++ )
        if ( minZ > points [regions[reg][idx]] [2] ) 
          minZ = points [regions[reg][idx]] [2];
      
      printLine (minX, minY, minZ, minX, maxY, minZ, ren, iren, 1.0, 1.0, 1.0);
      printLine (minX, maxY, minZ, maxX, maxY, minZ, ren, iren, 1.0, 1.0, 1.0);
      printLine (maxX, maxY, minZ, maxX, minY, minZ, ren, iren, 1.0, 1.0, 1.0);
      printLine (maxX, minY, minZ, minX, minY, minZ, ren, iren, 1.0, 1.0, 1.0);
        
      /// Optional ///
      double maxZ = -DBL_MAX;
      for ( int idx = 0 ; idx < (int)regions[reg].size() ; idx++ )
        if ( maxZ < points [regions[reg][idx]] [2] ) 
          maxZ = points [regions[reg][idx]] [2];
      
      /// lines commented for visualisation reasons ///
//       printLine (minX, minY, maxZ, minX, maxY, maxZ, ren, iren, 1.0, 1.0, 1.0);
//       printLine (minX, maxY, maxZ, maxX, maxY, maxZ, ren, iren, 1.0, 1.0, 1.0);
//       printLine (maxX, maxY, maxZ, maxX, minY, maxZ, ren, iren, 1.0, 1.0, 1.0);
//       printLine (maxX, minY, maxZ, minX, minY, maxZ, ren, iren, 1.0, 1.0, 1.0);
    }
  }
  
  if ( verbose )
  {
    iren->Render();
    iren->Start();
  }
}

vector<double> computePCA (ANNpointArray points, vector<vector<int> > &regions, vector<vector<int> > &boundaries, vtkRenderer* ren, vtkRenderWindowInteractor* iren, bool verbose=false)
{
  vector<double> magic_value;
  
  for (int reg = 0 ; reg < (int)regions.size() ; reg++ )
  {
    ANNpoint centroid = annAllocPt(2);
    ANNpoint eVal = NULL;
    ANNpointArray eVec = NULL;
    ANNpoint normal = annAllocPt (2);
    computeCentroidNoAlloc (points, 2, regions[reg] , centroid);
    computeNormalCurvatureNoAllocWithEig (points, 2, regions[reg], normal, eVal, eVec, centroid);
    
    double max_u = -DBL_MAX;
    double min_u =  DBL_MAX;
    double max_v = -DBL_MAX;
    double min_v =  DBL_MAX;
    
    /// just for visualisation resons ///
    double max_of_max_u = -DBL_MAX;
    double max_of_max_v = -DBL_MAX;
    
    for (int idx = 0 ; idx < (int)regions[reg].size() ; idx++)
    {
      ANNcoord c2p[3];
      c2p[0] = points[regions[reg][idx]][0] - centroid[0];
      c2p[1] = points[regions[reg][idx]][1] - centroid[1];
      c2p[2] = points[regions[reg][idx]][2] - centroid[2];
      
      double width = eVec[0][0]*c2p[0] + eVec[0][1]*c2p[1];
      if (width > max_u) max_u = width;
      if (width < min_u) min_u = width;
      
      double height = eVec[1][0]*c2p[0] + eVec[1][1]*c2p[1];
      if (height > max_v) max_v = height;
      if (height < min_v) min_v = height;
      
      /// just for visualisation resons ///
      if (max_u > max_of_max_u) max_of_max_u = max_u;
      if (max_v > max_of_max_v) max_of_max_v = max_v;
    }
    
    ANNcoord edge1[2], edge2[2], edge3[2], edge4[2];
    edge1[0] = centroid[0] + eVec[0][0]*max_u + eVec[1][0]*max_v;
    edge1[1] = centroid[1] + eVec[0][1]*max_u + eVec[1][1]*max_v;
    edge2[0] = centroid[0] + eVec[0][0]*max_u + eVec[1][0]*min_v;
    edge2[1] = centroid[1] + eVec[0][1]*max_u + eVec[1][1]*min_v;
    edge3[0] = centroid[0] + eVec[0][0]*min_u + eVec[1][0]*max_v;
    edge3[1] = centroid[1] + eVec[0][1]*min_u + eVec[1][1]*max_v;
    edge4[0] = centroid[0] + eVec[0][0]*min_u + eVec[1][0]*min_v;
    edge4[1] = centroid[1] + eVec[0][1]*min_u + eVec[1][1]*min_v;
    
    if ( verbose )
    {
      /// Print Object Contour ///
      double minZ = DBL_MAX;
      for (int pt = 0 ; pt < (int)regions[reg].size() ; pt++ )
        if (minZ > points [regions[reg][pt]] [2])
          minZ = points [regions[reg][pt]] [2];
      
      printLine (edge1[0], edge1[1], minZ, edge2[0], edge2[1], minZ, ren, iren, 0.0, 1.0, 1.0);
      printLine (edge2[0], edge2[1], minZ, edge4[0], edge4[1], minZ, ren, iren, 0.0, 1.0, 1.0);
      printLine (edge4[0], edge4[1], minZ, edge3[0], edge3[1], minZ, ren, iren, 0.0, 1.0, 1.0);
      printLine (edge3[0], edge3[1], minZ, edge1[0], edge1[1], minZ, ren, iren, 0.0, 1.0, 1.0);
      
      /// Optional ///
      double maxZ = -DBL_MAX;
      for (int pt = 0 ; pt < (int)regions[reg].size() ; pt++ )
        if (maxZ < points [regions[reg][pt]] [2])
          maxZ = points [regions[reg][pt]] [2];
      
      /// lines commented for visualisation reasons ///
//       printLine (edge1[0], edge1[1], maxZ, edge2[0], edge2[1], maxZ, ren, iren, 0.0, 1.0, 1.0);
//       printLine (edge2[0], edge2[1], maxZ, edge4[0], edge4[1], maxZ, ren, iren, 0.0, 1.0, 1.0);
//       printLine (edge4[0], edge4[1], maxZ, edge3[0], edge3[1], maxZ, ren, iren, 0.0, 1.0, 1.0);
//       printLine (edge3[0], edge3[1], maxZ, edge1[0], edge1[1], maxZ, ren, iren, 0.0, 1.0, 1.0);
      
      /// just for visualisation resons ///
//       printLine (centroid[0], centroid[1], maxZ, centroid[0] + eVec[0][0]*max_u, centroid[1] + eVec[0][1]*max_u, maxZ, ren, iren, 1.0, 0.0, 0.0);
//       printLine (centroid[0], centroid[1], maxZ, centroid[0] + eVec[1][0]*max_v, centroid[1] + eVec[1][1]*max_v, maxZ, ren, iren, 0.0, 1.0, 0.0);
      
      ANNcoord newXaxis[7] = {centroid[0], centroid[1], maxZ, centroid[0] + eVec[1][0]*max_of_max_v, centroid[1] + eVec[1][1]*max_of_max_v, maxZ, 0.0025};
      vtkActor* newXaxisActor = createVTKCylinder (newXaxis);
      newXaxisActor->GetProperty()->SetRepresentationToSurface();
      newXaxisActor->GetProperty()->SetColor (1.0, 0.0, 0.0);
      ren->AddActor (newXaxisActor);
      
      ANNcoord newYaxis[7] = {centroid[0], centroid[1], maxZ, centroid[0] + eVec[0][0]*max_of_max_u, centroid[1] + eVec[0][1]*max_of_max_u, maxZ, 0.0025};
      vtkActor* newYaxisActor = createVTKCylinder (newYaxis);
      newYaxisActor->GetProperty()->SetRepresentationToSurface();
      newYaxisActor->GetProperty()->SetColor (0.0, 1.0, 0.0);
      ren->AddActor (newYaxisActor);
      
      ANNcoord newZaxis[7] = {centroid[0], centroid[1], maxZ, centroid[0], centroid[1], maxZ+0.050, 0.0025};
      vtkActor* newZaxisActor = createVTKCylinder (newZaxis);
      newZaxisActor->GetProperty()->SetRepresentationToSurface();
      newZaxisActor->GetProperty()->SetColor (0.0, 0.0, 1.0);
      ren->AddActor (newZaxisActor);
    }
    
    double diagonal = sqrt ( _sqr(edge1[0]-edge4[0]) + _sqr(edge1[1]-edge4[1]) );
//     double vnorm = sqrt ( _sqr(edge1[0]-edge2[0]) + _sqr(edge1[1]-edge2[1]) );
//     double unorm = sqrt ( _sqr(edge2[0]-edge4[0]) + _sqr(edge2[1]-edge4[1]) );
    
    double sum_d = 0.0;
    for ( int idx=0 ; idx < (int)boundaries[reg].size() ; idx++ )
    {
      double x0 = points [boundaries[reg][idx]] [0];  
      double y0 = points [boundaries[reg][idx]] [1];
      
      double d1 = fabs( (edge2[0]-edge1[0])*(edge1[1]-y0) - (edge2[1]-edge1[1])*(edge1[0]-x0) ) / sqrt( _sqr(edge2[0]-edge1[0]) + _sqr(edge2[1]-edge1[1]) );
      double d2 = fabs( (edge4[0]-edge2[0])*(edge2[1]-y0) - (edge4[1]-edge2[1])*(edge2[0]-x0) ) / sqrt( _sqr(edge4[0]-edge2[0]) + _sqr(edge4[1]-edge2[1]) );
      double d3 = fabs( (edge3[0]-edge4[0])*(edge4[1]-y0) - (edge3[1]-edge4[1])*(edge4[0]-x0) ) / sqrt( _sqr(edge3[0]-edge4[0]) + _sqr(edge3[1]-edge4[1]) );
      double d4 = fabs( (edge1[0]-edge3[0])*(edge3[1]-y0) - (edge1[1]-edge3[1])*(edge3[0]-x0) ) / sqrt( _sqr(edge1[0]-edge3[0]) + _sqr(edge1[1]-edge3[1]) );
      
      double min_d = min ( min (d1, d2), min (d3, d4) ) / diagonal ;
//       double min_d;
//       if ( min (d1, d3) < min (d2, d4) )
//       {
//         min_d = min (d1, d3);
//         min_d = min_d / unorm;
//       }
//       else 
//       {
//         min_d = min (d2, d4);
//         min_d = min_d / vnorm;
//       }
      
      sum_d = sum_d + min_d;
    }
    
    magic_value.push_back (sum_d / boundaries[reg].size());
  }
      
  if ( verbose )
  {
    iren->Render();
    iren->Start();
  }
  
  return magic_value;
}

vector<double> LaimLama (ANNpointArray points, vector<vector<int> > &regions, vector<vector<int> > &boundaries, vector<vector<int> > &thick_boundaries, vtkRenderer* ren, vtkRenderWindowInteractor* iren,
                         bool verbose=false)
{
  vector<double> lama_value;
  
  for ( int reg=0 ; reg < (int)regions.size() ; reg++ )
  {
    vector<int> inliers, samples;
    int max_iterations = thick_boundaries[reg].size();
    int iterations = fitLine (points, thick_boundaries[reg], inliers, samples, max_iterations);
    double per = 100.0 * inliers.size() / thick_boundaries[reg].size();
    
    if ( verbose )
    {
      fprintf     (stderr, " contour Line for Region #%2d has", reg);
      print_error (stderr, " %4d inliers [%6.2f%]", (int)inliers.size(), per); 
      fprintf     (stderr, " found in"); 
      print_error (stderr, " %4d iterations", iterations);
      fprintf     (stderr, " | Model: P1 = (%6.3f,%6.3f) P2 = (%6.3f,%6.3f)\n", points[samples[0]][0], points[samples[0]][1], points[samples[1]][0], points[samples[1]][1]);
    }
    
    double x1 = points[samples[0]][0];
    double y1 = points[samples[0]][1];
    double x2 = points[samples[1]][0];
    double y2 = points[samples[1]][1];

    double minZ = DBL_MAX;
    for ( int idx = 0 ; idx < (int)regions[reg].size() ; idx++ )
      if ( minZ > points [regions[reg][idx]] [2] ) 
        minZ = points [regions[reg][idx]] [2];
    
    double maxZ = -DBL_MAX;
    for ( int idx = 0 ; idx < (int)regions[reg].size() ; idx++ )
      if ( maxZ < points [regions[reg][idx]] [2] ) 
        maxZ = points [regions[reg][idx]] [2];
    
    /// compute line vector ///
    double l[3];
    l[0] = x2 - x1;
    l[1] = y2 - y1;
    l[2] = 0.0;
    double nl = sqrt ( _sqr(l[0]) + _sqr(l[1]) + _sqr(l[2]) );
    l[0] = l[0] / nl;
    l[1] = l[1] / nl;
    l[2] = l[2] / nl;
    
    double n[3];
    n[0] = 0.0;
    n[1] = 0.0;
    n[2] = 1.0;
    
    double m[3];
    m[0] = l[1]*n[2] - l[2]*n[1];
    m[1] = l[2]*n[0] - l[0]*n[2];
    m[2] = l[0]*n[1] - l[1]*n[0];
    
    /// get inliers limits lenghtwise and crosswise ///
    double minDistLW =  DBL_MAX;
    double maxDistLW = -DBL_MAX;
    double minDistCW =  DBL_MAX;
    double maxDistCW = -DBL_MAX;
    for ( int i=0 ; i < (int)regions[reg].size() ; i++ )
    {
      double p[2];
      p[0] = points [regions[reg][i]] [0] - x1;
      p[1] = points [regions[reg][i]] [1] - y1;
      
      double DistLW = (l[0] * p[0]) + (l[1] * p[1]);
      if ( minDistLW > DistLW )  minDistLW = DistLW;
      if ( maxDistLW < DistLW )  maxDistLW = DistLW;
      
      double DistCW = (m[0] * p[0]) + (m[1] * p[1]);
      if ( minDistCW > DistCW )  minDistCW = DistCW;
      if ( maxDistCW < DistCW )  maxDistCW = DistCW;
    }
    
    /// compute plane edges /// generated in circle order ///
    double edges[4][3];
    edges[0][0] = x1 + l[0]*minDistLW;      edges[0][1] = y1 + l[1]*minDistLW;      edges[0][2] = minZ;
    edges[1][0] = x1 + l[0]*maxDistLW;      edges[1][1] = y1 + l[1]*maxDistLW;      edges[1][2] = minZ;
    
    if ( verbose )
    {
      /// print line inliers //
      ren->AddActor(createActorFromDataSet(ANNToVTK(points, inliers), 1.0, 0.5, 0.0, point_size, false));
      /// print 2D line //
//       printLine (points[samples[0]][0], points[samples[0]][1], 0.0, points[samples[1]][0], points[samples[1]][1], 0.0, ren, iren, 1.0, 0.5, 0.0);
      /// print 3D line //
//       printLine (points[samples[0]][0], points[samples[0]][1], points[samples[0]][2], points[samples[1]][0], points[samples[1]][1], points[samples[1]][2], ren, iren, 1.0, 0.5, 0.0);
      /// print 2D line LengthWise ///
//       printLine (edges[0][0], edges[0][1], 0.0, edges[1][0], edges[1][1], 0.0, ren, iren, 1.0, 0.5, 0.0);
    }
    
    double width;
    double cuboid[8][3];
    
    width =  maxDistCW;
    cuboid[0][0] = edges[0][0] + width*m[0];        cuboid[0][1] = edges[0][1] + width*m[1];        cuboid[0][2] = edges[0][2] + width*m[2];
    cuboid[1][0] = edges[1][0] + width*m[0];        cuboid[1][1] = edges[1][1] + width*m[1];        cuboid[1][2] = edges[1][2] + width*m[2];
    
    width = -minDistCW;
    cuboid[4][0] = edges[0][0] - width*m[0];        cuboid[4][1] = edges[0][1] - width*m[1];        cuboid[4][2] = edges[0][2] - width*m[2];
    cuboid[5][0] = edges[1][0] - width*m[0];        cuboid[5][1] = edges[1][1] - width*m[1];        cuboid[5][2] = edges[1][2] - width*m[2];
    
    if ( verbose )
    {
      /// contour when z is minZ ///
      printLine (cuboid[0][0], cuboid[0][1], minZ, cuboid[1][0], cuboid[1][1], minZ, ren, iren, 1.0, 0.5, 0.0);
      printLine (cuboid[1][0], cuboid[1][1], minZ, cuboid[5][0], cuboid[5][1], minZ, ren, iren, 1.0, 0.5, 0.0);
      printLine (cuboid[5][0], cuboid[5][1], minZ, cuboid[4][0], cuboid[4][1], minZ, ren, iren, 1.0, 0.5, 0.0);
      printLine (cuboid[4][0], cuboid[4][1], minZ, cuboid[0][0], cuboid[0][1], minZ, ren, iren, 1.0, 0.5, 0.0);    
      
      /// contour when z is maxZ ///
      /// lines commented for visualisation reasons ///
//       printLine (cuboid[0][0], cuboid[0][1], maxZ, cuboid[1][0], cuboid[1][1], maxZ, ren, iren, 1.0, 0.5, 0.0);
//       printLine (cuboid[1][0], cuboid[1][1], maxZ, cuboid[5][0], cuboid[5][1], maxZ, ren, iren, 1.0, 0.5, 0.0);
//       printLine (cuboid[5][0], cuboid[5][1], maxZ, cuboid[4][0], cuboid[4][1], maxZ, ren, iren, 1.0, 0.5, 0.0);
//       printLine (cuboid[4][0], cuboid[4][1], maxZ, cuboid[0][0], cuboid[0][1], maxZ, ren, iren, 1.0, 0.5, 0.0);
    }
    
    double diagonal = sqrt ( _sqr(cuboid[0][0]-cuboid[5][0]) + _sqr(cuboid[0][1]-cuboid[5][1]) );
//     double normalizeLW = sqrt ( _sqr(cuboid[0][0]-cuboid[1][0]) + _sqr(cuboid[0][1]-cuboid[1][1]) );
//     double normalizeCW = sqrt ( _sqr(cuboid[1][0]-cuboid[5][0]) + _sqr(cuboid[1][1]-cuboid[5][1]) );
    
    double sum_d = 0.0;
    for ( int idx=0 ; idx < (int)boundaries[reg].size() ; idx++ )
    {
      double x0 = points [boundaries[reg][idx]] [0];
      double y0 = points [boundaries[reg][idx]] [1];
      
      double d1 = fabs( (cuboid[0][0]-cuboid[1][0])*(cuboid[1][1]-y0) - (cuboid[0][1]-cuboid[1][1])*(cuboid[1][0]-x0) ) / sqrt( _sqr(cuboid[0][0]-cuboid[1][0]) + _sqr(cuboid[0][1]-cuboid[1][1]) );
      double d2 = fabs( (cuboid[1][0]-cuboid[5][0])*(cuboid[5][1]-y0) - (cuboid[1][1]-cuboid[5][1])*(cuboid[5][0]-x0) ) / sqrt( _sqr(cuboid[1][0]-cuboid[5][0]) + _sqr(cuboid[1][1]-cuboid[5][1]) );
      double d3 = fabs( (cuboid[5][0]-cuboid[4][0])*(cuboid[4][1]-y0) - (cuboid[5][1]-cuboid[4][1])*(cuboid[4][0]-x0) ) / sqrt( _sqr(cuboid[5][0]-cuboid[4][0]) + _sqr(cuboid[5][1]-cuboid[4][1]) );
      double d4 = fabs( (cuboid[4][0]-cuboid[0][0])*(cuboid[0][1]-y0) - (cuboid[4][1]-cuboid[0][1])*(cuboid[0][0]-x0) ) / sqrt( _sqr(cuboid[4][0]-cuboid[0][0]) + _sqr(cuboid[4][1]-cuboid[0][1]) );      
      
      double min_d = min ( min (d1, d2), min (d3, d4) ) / diagonal ;
//       double min_d;
//       if ( min (d1, d3) < min (d2, d4) )
//       {
//         min_d = min (d1, d3);
//         min_d = min_d / normalizeCW;
//       }
//       else
//       {
//         min_d = min (d2, d4);
//         min_d = min_d / normalizeLW;
//       }
      
      sum_d = sum_d + min_d;
    }
    
    lama_value.push_back (sum_d / boundaries[reg].size());
  }
  
  if ( verbose )
  {
    iren->Render();
    iren->Start();
  }
  
  return lama_value;
}

/// Subtract subset vector V2 from vector V1 ///
vector<int> subtractSubset (vector<int> &v1, vector<int> &v2)
{
  sort (v1.begin(), v1.end());
  sort (v2.begin(), v2.end());
  
  v1.erase ( unique(v1.begin(), v1.end()), v1.end());
  v2.erase ( unique(v2.begin(), v2.end()), v2.end());
  
  int i=0, j=0;
  do
  {
    if (v1[i] == v2[j])
    {
      v1.erase(v1.begin() + i);
      j++;
    }
    else
    {
      i++;
    }
  } while ( ( i < (int)v1.size() ) ||  ( j < (int)v2.size() ) );
  
  return v1;
}

/// Merging Lines inside a Region ///
void mergeLines (shape s, vector<shape> &shapes, double thresh, vtkRenderer* ren, vtkRenderWindowInteractor* iren)
{
  bool merged = false;
  
  ANNcoord u[2]; 
  u[0] = s.model[0] - s.model[3];
  u[1] = s.model[1] - s.model[4];
  
  for (int sh = 0; sh < (int)shapes.size (); sh++)
  {
    if ( shapes[sh].type == 0 )
    {
      ANNcoord v[2];
      v[0] = shapes[sh].model[0] - shapes[sh].model[3];
      v[1] = shapes[sh].model[1] - shapes[sh].model[4];
      
      double uv = u[0]*v[0] + u[1]*v[1];
      double du = sqrt (_sqr(u[0]) + _sqr(u[1]));
      double dv = sqrt (_sqr(v[0]) + _sqr(v[1]));
      
      // angle is a value between 0 and PI radians //
      double angle = acos (uv / (du*dv));
      
      if ( (fabs (angle - 0.0) < thresh) || (fabs (angle - M_PI/2) < thresh) || (fabs (angle - M_PI) < thresh) )
      {
        merged = true;
        
        shapes[sh].inliers.insert (shapes[sh].inliers.begin(), s.inliers.begin(), s.inliers.end());
        
        /// this line is commented just for visualisation rasons ///
//         printLine (s.model[0], s.model[1], 0.0, s.model[3], s.model[4], 0.0, ren, iren, 0.0, 0.0, 0.0, model_step);
        
        break;
      }
    }
  }
  
  if ( ! merged )
    shapes.push_back (s);
}

/// Merging Circles inside a Region ///
void mergeCircles (shape s, vector<shape> &shapes, vtkRenderer* ren, vtkRenderWindowInteractor* iren)
{
  bool merged = false;
  
  for (int sh = 0 ; sh < (int)shapes.size() ; sh++)
  {
    if (shapes[sh].type == 1)
    {
      double d = sqrt ( _sqr(s.model[0] - shapes[sh].model[0]) + _sqr(s.model[1] - shapes[sh].model[1]) );
      
      /// Condition for merging two circles ///
      if ( max ( s.model[3], shapes[sh].model[3] ) > d )
      {
        merged = true;
        
        /// New Model Obtained with Ponderate Average ///
        ANNpoint merged_center = annAllocPt (2);
        merged_center[0]  = (shapes[sh].model[0]*shapes[sh].inliers.size() + s.model[0]*s.inliers.size()) / (s.inliers.size() + shapes[sh].inliers.size());
        merged_center[1]  = (shapes[sh].model[1]*shapes[sh].inliers.size() + s.model[1]*s.inliers.size()) / (s.inliers.size() + shapes[sh].inliers.size());
        double merged_radius = (shapes[sh].model[3]*shapes[sh].inliers.size() + s.model[3]*s.inliers.size()) / (s.inliers.size() + shapes[sh].inliers.size());
        
        vector <int> merged_inliers;
        merged_inliers.insert (merged_inliers.end(), shapes[sh].inliers.begin(), shapes[sh].inliers.end());
        merged_inliers.insert (merged_inliers.end(), s.inliers.begin(), s.inliers.end());
        
//         vector<int> kept_inliers;
//         for (int m = 0 ; m < (int)merged_inliers.size() ; m++)
//         {
//           double x0 = points [merged_inliers[m]] [0];
//           double y0 = points [merged_inliers[m]] [1];
//           double d = sqrt( _sqr (merged_center[0] - x0) + _sqr (merged_center[1] - y0) ) - merged_radius ;
//           if ( fabs(d) < circle_thresh )
//             kept_inliers.push_back (merged_inliers[m]);
//         }
        
        printCircle (shapes[sh].model[0], shapes[sh].model[1], 0.0, shapes[sh].model[3], ren, iren, 0.0, 0.0, 0.0, model_step);
        
        printCircle (s.model[0], s.model[1], 0.0, s.model[3], ren, iren, 0.0, 0.0, 0.0, model_step);
        
        printCircle (merged_center[0], merged_center[1], 0.0, merged_radius, ren, iren, 0.0, 1.0, 0.0, model_step);
        
        /// Store Merge Circle ///
        shapes[sh].model[0] = merged_center[0];
        shapes[sh].model[1] = merged_center[1];
        shapes[sh].model[2] = 0.0;
        shapes[sh].model[3] = merged_radius;
        shapes[sh].inliers  = merged_inliers;
      }
    }
  }
  
  if ( ! merged )
    shapes.push_back (s);
}

/// Fit Only Lines ///
void fitOnlyLines (ANNpointArray points, vector<int> &thick_region_boundaries, vector<shape> &shapes, int min_inliers_line, double line_merging_thresh, vtkRenderer* ren, vtkRenderWindowInteractor* iren, 
                   double R, double G, double B, char* type_of_lines)
{
  int fit = 0;
  
  do
  {
    vector<int> only_line_inliers, only_line_samples;
    int only_max_iterations_line = thick_region_boundaries.size();
    int only_iterations_line = fitLine (points, thick_region_boundaries, only_line_inliers, only_line_samples, only_max_iterations_line);
    double only_per_line = 100.0 * only_line_inliers.size() / thick_region_boundaries.size();
    
    fprintf     (stderr, "      %s Line #%2d has", type_of_lines, fit);
    print_error (stderr, " %4d inliers [%6.2f%]", (int)only_line_inliers.size(), only_per_line); 
    fprintf     (stderr, " found in"); 
    print_error (stderr, " %4d iterations", only_iterations_line);
    fprintf     (stderr, " | Model: P1 = (%6.3f,%6.3f) P2 = (%6.3f,%6.3f)\n", points[only_line_samples[0]][0], points[only_line_samples[0]][1], points[only_line_samples[1]][0], points[only_line_samples[1]][1]);
    
    if ( (int)only_line_inliers.size() >= min_inliers_line )
    {
      double x1 =  points [only_line_samples[0]] [0];
      double y1 =  points [only_line_samples[0]] [1];
      double x2 =  points [only_line_samples[1]] [0];
      double y2 =  points [only_line_samples[1]] [1];
      
      computeLineLengthwise (points, only_line_inliers, x1, y1, x2, y2);
      
      shape only_shape;
      only_shape.type = 0;
      only_shape.model = annAllocPt(6);
      only_shape.model[0] = x1;
      only_shape.model[1] = y1;
      only_shape.model[2] = 0.0;
      only_shape.model[3] = x2;
      only_shape.model[4] = y2;
      only_shape.model[5] = 0.0;
      only_shape.inliers = only_line_inliers;
      
      ren->AddActor (createActorFromDataSet (ANNToVTK(points,  only_shape.inliers), R, G, B, point_size, false));
      
      printLine (only_shape.model[0], only_shape.model[1], 0.0, only_shape.model[3], only_shape.model[4], 0.0, ren, iren, R, G, B, model_step);
      
      /// Merge Lines ///
      mergeLines (only_shape, shapes, line_merging_thresh, ren, iren);
    }
    
    thick_region_boundaries = subtractSubset (thick_region_boundaries, only_line_inliers);
    
    fit++;
    
    /// Print the Number of Points Left for Model Fitting ///
    if ( (int)thick_region_boundaries.size() < min_inliers_line )
      print_value (stderr, "      %d < %d | Stop ! \n", (int)thick_region_boundaries.size(), min_inliers_line);
    else
      if ( (int)thick_region_boundaries.size() > min_inliers_line )
        print_value (stderr, "      %d > %d | Continue.. \n", (int)thick_region_boundaries.size(), min_inliers_line);
    else
      print_value (stderr, "      %d = %d | Continue.. \n", (int)thick_region_boundaries.size(), min_inliers_line);
    
  } while ( (int)thick_region_boundaries.size() >= min_inliers_line );
}

/// COMPUTE SHAPES FROM REGIONS ///
vector<vector<shape> > getShapes (ANNpointArray points, PCD_Header header, vector<vector<int> > &regions, vector<vector<int> > &boundaries, vector<vector<int> > &thick_boundaries, vector<double> &magic_value, int kIdx, 
                                  ANNkd_tree * kd_tree, ANNidxArray nnIdx, ANNdistArray sqrDists, vtkRenderer* ren, vtkRenderWindowInteractor * iren)
{
  vector<vector<shape> > all_shapes;
  
  for ( int reg = 0 ; reg < (int)regions.size(); reg++ )
  {
    // Declare Timer //
    tictoc region_timer;
    // Starting Timer //
    region_timer.tic ();
    
    fprintf     (stderr, "Layer[%d] has ", reg); 
    print_error (stderr, "%d points ", regions[reg].size());
    fprintf     (stderr, "out of which "); 
    print_error (stderr, "%d boundary ", boundaries[reg].size());
    fprintf     (stderr, "and "); 
    print_error (stderr, "%d thick boundary ", thick_boundaries[reg].size());
    fprintf     (stderr, "( magic = %f ) \n", magic_value[reg]);
    
    /// Save Thick Boundaries ///
    vector<int> thick_region_boundaries = thick_boundaries[reg];
    
    vector<shape> shapes;
    
    if ( magic_value[reg] < rectanguloid_approximation )
    {
      /// Fit Only Line Models ///
      char type_of_lines[] = "only";
      fitOnlyLines (points, thick_boundaries[reg], shapes, min_inliers_line, line_merging_thresh, ren, iren, 1.0, 0.0, 0.0, type_of_lines);
    }
    else
    {
      /// Fit Line and Circle Models ///
      int fit = 0;
      do
      {
        vector<int> best_inliers_line, best_samples_line;
        int max_iterations_line = thick_boundaries[reg].size();
        int iterations_line = fitLine (points, thick_boundaries[reg], best_inliers_line, best_samples_line, max_iterations_line);
        double per_line = 100.0 * best_inliers_line.size() / thick_boundaries[reg].size();
        
        vector<int> best_inliers_circle, best_samples_circle;
        double max_iterations_circle = thick_boundaries[reg].size();
        double max_r = min ( RegionLimit (points, thick_boundaries[reg]), max_rad );
        ANNpoint best_c = annAllocPt (2);
        double best_r;
        int iterations_circle = fitCircle (points, thick_boundaries[reg], best_inliers_circle, best_samples_circle, max_iterations_circle, max_r, best_c, best_r);
        double per_circle = 100.0 * best_inliers_circle.size() / thick_boundaries[reg].size();
        
        fprintf     (stderr, "     Line #%2d has", fit);
        print_error (stderr, " %4d inliers [%6.2f%]", (int)best_inliers_line.size(), per_line); 
        fprintf     (stderr, " found in"); 
        print_error (stderr, " %4d iterations", iterations_line);
        fprintf     (stderr, " | Model: P1 = (%6.3f,%6.3f) P2 = (%6.3f,%6.3f)\n", points[best_samples_line[0]][0], points[best_samples_line[0]][1], points[best_samples_line[1]][0], points[best_samples_line[1]][1]);
        
        fprintf     (stderr, "   Circle #%2d has", fit);
        print_error (stderr, " %4d inliers [%6.2f%]", (int)best_inliers_circle.size(), per_circle); 
        fprintf     (stderr, " found in"); 
        print_error (stderr, " %4d iterations", iterations_circle);
        fprintf     (stderr, " | Model:  C = (%6.3f,%6.3f)  R = %5.3f in [%5.3f, %5.3f]\n", best_c[0], best_c[1], best_r, min_rad, max_r);
        
        /// Select The Best Fit ///
        if ( best_inliers_line.size() >= best_inliers_circle.size() )
        {
          /// Line Model Selected /// 
          if ( (int)best_inliers_line.size() >= min_inliers_line )
          {
            double x1 =  points [best_samples_line[0]] [0];
            double y1 =  points [best_samples_line[0]] [1];
            double x2 =  points [best_samples_line[1]] [0];
            double y2 =  points [best_samples_line[1]] [1];
            
            computeLineLengthwise (points, best_inliers_line, x1, y1, x2, y2);
            
            shape s;
            s.type = 0;
            s.model = annAllocPt(6);
            s.model[0] = x1;  
            s.model[1] = y1;  
            s.model[2] = 0.0;
            s.model[3] = x2;  
            s.model[4] = y2;  
            s.model[5] = 0.0;
            s.inliers = best_inliers_line;
            
            ren->AddActor(createActorFromDataSet(ANNToVTK(points, s.inliers), 1.0, 0.0, 0.0, point_size, false));
            
            printLine (s.model[0], s.model[1], 0.0, s.model[3], s.model[4], 0.0, ren, iren, 1.0, 0.0, 0.0, model_step);
            
            /// Merge Lines ///
            mergeLines (s, shapes, line_merging_thresh, ren, iren);
          }
          
          thick_boundaries[reg] = subtractSubset (thick_boundaries[reg], best_inliers_line);
        }
        else
        {
          /// Circle Model Selected /// 
          if ( (int)best_inliers_circle.size() >= min_inliers_circle )
          {
            // double boundary_percentage = (double)thick_boundaries[reg].size () / (double)regions[reg].size ();
            double boundary_percentage = per_circle / 100.0;
            
            bool decompose1 /*= false*/ ;
            bool decompose2 = false;
            
            if ( boundary_percentage < boundary_thresh )
              decompose1 = true;
            else
              decompose1 = false;
            
            
            
            if ( ! decompose1 )
            {
              
      // create points from indices //
      ANNpointArray points_of_region = doPointsOfIndices (points, header.nr_points, thick_boundaries[reg]);
      
      // create KD-Tree of Layer //
      ANNkd_tree* kd_tree_reg = new ANNkd_tree (points_of_region, header.nr_points, 2, 25);
      ANNidxArray nnIdx_reg = new ANNidx [max_nr_nn];
      ANNdistArray sqrDists_reg = new ANNdist [max_nr_nn];
      
      vector<vector<int> > regions;
      
      double sqr_thresh_connectivity = connectivity_thresh * connectivity_thresh;
      regions = OptimizedRegionSegmentationDistanceBasedNoMarking (points_of_region, header.nr_points, thick_boundaries[reg], 1, kd_tree_reg, nnIdx_reg, sqrDists_reg, max_nr_nn, -1, -1, sqr_thresh_connectivity, false);
      
      if ( (int)regions.size() > 1 )
      {
        print_warning (stderr, "   ! found %d regions ! the circle will be decomposed !", (int)regions.size());
        decompose1 = true;
        decompose2 = true;
      }
    
            }
            
            
            
            if ( decompose1 )
            {
              print_value (stderr, "   %.2f%% < %.2f%% | Decompose Circle: \n", boundary_percentage * 100.0, boundary_thresh * 100.0);
              
              vector<int> if_region_boundary_points = thick_boundaries[reg];
              vector<shape> if_shapes;
              char type_of_lines[] = "if";
              fitOnlyLines (points, if_region_boundary_points, if_shapes, min_inliers_line, line_merging_thresh / 2, ren, iren, 1.0, 0.5, 0.0, type_of_lines);
              
              /// Find the if line which has max inliers ///
              int if_max_idx = 0;
              int if_max_inliers = 0;
              for ( int g = 0 ; g < (int)if_shapes.size() ; g++ )
              {
                if ( if_max_inliers < (int)if_shapes[g].inliers.size() )
                {
                  if_max_idx = g;
                  if_max_inliers = if_shapes[g].inliers.size();
                }
              }
              
              print_warning (stderr, "         if lines = %d [inliers]  vs  circle = %d [inliers] \n", if_max_inliers, (int)best_inliers_circle.size());
              
              /// cool trick with decompose2 /// got to make it less complicated ///
              if ( ( if_max_inliers > ((int)best_inliers_circle.size()) ) || (decompose2) )
              {
                for ( int h = 0 ; h < (int)if_shapes.size() ; h++ )
                  mergeLines (if_shapes[h], shapes, line_merging_thresh, ren, iren);
                
                thick_boundaries[reg] = if_region_boundary_points;
              }
              else
              {
                getInliersDisk (points, thick_boundaries[reg], best_inliers_circle, best_c, best_r);
                
                shape s;
                s.type = 1;
                s.model = annAllocPt(4);
                s.model[0] = best_c[0]; /// cx
                s.model[1] = best_c[1]; /// cy
                s.model[2] = 0.0;       /// cz
                s.model[3] = best_r;    /// r
                s.inliers = best_inliers_circle;
                
                ren->AddActor (createActorFromDataSet (ANNToVTK (points, best_inliers_circle), 0.0, 1.0, 0.0, point_size, false));
                
                printCircle (s.model[0], s.model[1], 0.0, s.model[3], ren, iren, 0.0, 1.0, 0.0, model_step);
                
                /// Merge circles ///
                mergeCircles (s, shapes, ren, iren);
                
                thick_boundaries[reg] = subtractSubset (thick_boundaries[reg], best_inliers_circle);
              }
            }
            else
            {
              if ( boundary_percentage == boundary_thresh ) 
                print_value (stderr, "   %.2f%% = %.2f%% | Do Not Decompose Circle ! \n", boundary_percentage * 100.0, boundary_thresh * 100.0);
              else
                print_value (stderr, "   %.2f%% > %.2f%% | Do Not Decompose Circle ! \n", boundary_percentage * 100.0, boundary_thresh * 100.0);
              
              getInliersDisk (points, thick_boundaries[reg], best_inliers_circle, best_c, best_r);
              
              shape s;
              s.type = 1;
              s.model = annAllocPt(4);
              s.model[0] = best_c[0]; /// cx
              s.model[1] = best_c[1]; /// cy
              s.model[2] = 0.0;       /// cz
              s.model[3] = best_r;    /// r
              s.inliers = best_inliers_circle;
                    
              ren->AddActor (createActorFromDataSet (ANNToVTK (points, best_inliers_circle), 0.0, 1.0, 0.0, point_size, false));
              
              printCircle (s.model[0], s.model[1], 0.0, s.model[3], ren, iren, 0.0, 1.0, 0.0, model_step);
              
              /// Merge circles ///
              mergeCircles (s, shapes, ren, iren);
              
              thick_boundaries[reg] = subtractSubset (thick_boundaries[reg], best_inliers_circle);
            }
          }
          else
          {
            /// this little trick creates more problems than it solves ///
            // char type_of_lines[] = "left";
            // fitOnlyLines (points, thick_boundaries[reg], shapes, min_inliers_line, line_merging_thresh, ren, iren, 1.0, 0.5, 0.0, type_of_lines);
            
            thick_boundaries[reg] = subtractSubset (thick_boundaries[reg], best_inliers_circle);
          }
        }
        
        fit++;
        
        /// Print the Number of Points Left for Model Fitting ///
        if ( (int)thick_boundaries[reg].size() < min (min_inliers_line, min_inliers_circle) )
          print_value (stderr, "   %d < %d | Stop ! \n", (int)thick_boundaries[reg].size(), min (min_inliers_line, min_inliers_circle));
        else
          if ( (int)thick_boundaries[reg].size() > min (min_inliers_line, min_inliers_circle) )
            print_value (stderr, "   %d > %d | Continue.. \n", (int)thick_boundaries[reg].size(), min (min_inliers_line, min_inliers_circle));
        else
          print_value (stderr, "   %d = %d | Continue.. \n", (int)thick_boundaries[reg].size(), min (min_inliers_line, min_inliers_circle));
        
      } while ( (int)thick_boundaries[reg].size() >= min (min_inliers_line, min_inliers_circle) );
    }
    
    /// Add shapes to all shapes ///
    all_shapes.push_back (shapes);
    
    /// Restore Thcick Boundaries ///
    thick_boundaries[reg] = thick_region_boundaries;
    
    /// Displaying Time ///
    fprintf (stderr, "----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------");
    fprintf (stderr, " Done in %5.2g", region_timer.toc ()); fprintf (stderr, " [s]\n");
    
    if ( region_step )
    {
      iren->Render();
      iren->Start();
    }
  }
  
  return all_shapes;
}

/// MERGE TWO REGIONS BY MERGING CIRCLES ///
void mergeRegions (ANNpointArray points, vector<vector<int> > &regions, vector<vector<int> > &boundaries, vector<vector<shape> > &all_shapes, vtkRenderer* ren, vtkRenderWindowInteractor* iren)
{
  for (int r=0; r < (int)all_shapes.size(); r++)
  {
    for (int s=0; s < (int)all_shapes[r].size(); s++)
    {
      if (all_shapes[r][s].type == 1)
      {
        for (int t=r+1; t < (int)all_shapes.size(); t++)
        {
          for (int u=0; u < (int)all_shapes[t].size(); u++)
          {
            if (all_shapes[t][u].type == 1)
            {
              double d = sqrt ( _sqr (all_shapes[r][s].model[0] - all_shapes[t][u].model[0]) + _sqr (all_shapes[r][s].model[1] - all_shapes[t][u].model[1]) );
              
              /// if two circles overlap, then they are merged //
              if ( (all_shapes[r][s].model[3] + all_shapes[t][u].model[3]) > d )
                // /// if at least one of the two circles overlap half way trough, then they are merged ///
              // if ( max (all_shapes[r][s].model[3], all_shapes[t][u].model[3]) > d )
              {
                vector<int> merged_inliers;
                merged_inliers.insert (merged_inliers.end(), all_shapes[r][s].inliers.begin(), all_shapes[r][s].inliers.end());
                merged_inliers.insert (merged_inliers.end(), all_shapes[t][u].inliers.begin(), all_shapes[t][u].inliers.end());
                
                ren->AddActor (createActorFromDataSet (ANNToVTK (points, merged_inliers), 0.5, 0.5, 0.5, point_size, false));
                
                if ( model_step )
                {
                  iren->Render();
                  iren->Start();
                }
                
                vector<int> inliers, samples;
                double max_iterations_circle = merged_inliers.size();
                double max_r = min ( RegionLimit(points, merged_inliers), max_rad );
                ANNpoint center = annAllocPt (2);
                double radius = 0.0;
                int iterations_circle = fitCircle (points, merged_inliers, inliers, samples, max_iterations_circle, max_r, center, radius);
                double per_circle = 100.0 * inliers.size() / merged_inliers.size();
                
                getInliersDisk (points, merged_inliers, inliers, center, radius);
                
                /// Update all_shapes ///
                /// Store the new Circle ///
                all_shapes[r][s].model[0] = center[0];
                all_shapes[r][s].model[1] = center[1];
                all_shapes[r][s].model[2] = 0.0;
                all_shapes[r][s].model[3] = radius;
                all_shapes[r][s].inliers  = inliers;
                /// Delete the last Circle ///
                all_shapes[t].erase (all_shapes[t].begin() + u);
                /// Merge Regions Shapes ///
                all_shapes[r].insert (all_shapes[r].end(), all_shapes[t].begin(), all_shapes[t].end());
                /// Delete remaining Shapes ///
                all_shapes.erase (all_shapes.begin() + t);
                
                /// Update regions ///
                /// Merge region r with region t ///
                regions[r].insert (regions[r].end(), regions[t].begin(), regions[t].end());
                /// Delete region t ///
                regions.erase (regions.begin() + t);
                
                /// Update boundaries ///
                /// Merge boundaries of region r with boundaries of region t ///
                boundaries[r].insert (boundaries[r].end(), boundaries[t].begin(), boundaries[t].end());
                /// Delete boundaries of region t ///
                boundaries.erase (boundaries.begin() + t);
                
                print_info  (stderr, "Region %2d Merged with Region %2d | Merged Circle has ", r, t);
                print_error (stderr, "%4d inliers [%6.2f%%] ", (int)inliers.size(), per_circle); 
                fprintf     (stderr, "found in "); 
                print_error (stderr, "%4d iterations ", iterations_circle);
                fprintf     (stderr, "| Model: C = (%6.3f,%6.3f) R = %5.3f in [%5.3f, %5.3f] | Stored at Region %2d \n", center[0], center[1], radius, min_rad, max_r, r);
                
                ren->AddActor (createActorFromDataSet (ANNToVTK (points, inliers), 0.0, 0.0, 1.0, point_size, false));
                printCircle (center[0], center[1], 0.0, radius, ren, iren, 0.0, 0.0, 1.0, model_step);
                
                /// WE DON'T SKIP A REGION
                t--;
              }
            }
          }
        }
      }
    }
  }
}

/// TRANSITION FROM LINE TO BOX /// COMPUTE GRID AND NEGATIVE POINTS ///
void gridEdges (vector<ANNpoint> &all_grids, vector<ANNpoint> &all_negative, double cuboid[8][3], ANNkd_tree* kd_tree_negative, double sqr_negative_thresh)
{
  for (int c = 0 ; c < 8 ; c++)
  {
    ANNpoint point = annAllocPt (3);
    point[0] = cuboid[c][0];
    point[1] = cuboid[c][1];
    point[2] = cuboid[c][2];
    
    int k_negative = kd_tree_negative->annkFRSearch (point, sqr_negative_thresh, 0, NULL, NULL, 0.0);
    if ( k_negative == 0 )
    {
      all_negative.push_back (point);
    }
    all_grids.push_back (point);
  }
}

void gridLine (vector<ANNpoint> &all_grids, vector<ANNpoint> &all_negative, double p1[], double p2[], ANNkd_tree* kd_tree_negative, double sqr_negative_thresh)
{
  ANNcoord v[3];
  v[0] = p2[0] - p1[0];
  v[1] = p2[1] - p1[1];
  v[2] = p2[2] - p1[2];  
  double dv = sqrt ( _sqr(v[0]) + _sqr(v[1]) + _sqr(v[2]) );
  v[0] = v[0] / dv;
  v[1] = v[1] / dv;
  v[2] = v[2] / dv;
  
  for (double v_step = res ; v_step <= dv/*-res*/ ; v_step = v_step + res)
  {
    ANNpoint point = annAllocPt (3);
    point[0] = p1[0] + v_step*v[0];
    point[1] = p1[1] + v_step*v[1];
    point[2] = p1[2] + v_step*v[2];
    
    int k_negative = kd_tree_negative->annkFRSearch (point, sqr_negative_thresh, 0, NULL, NULL, 0.0);
    if ( k_negative == 0 )
    {
      all_negative.push_back (point);
    }
    all_grids.push_back (point);
  }
}

void gridPlane (vector<ANNpoint> &all_grids, vector<ANNpoint> &all_negative, double p[], double p1[], double p2[], ANNkd_tree* kd_tree_negative, double sqr_negative_thresh)
{
  ANNcoord v[3];
  v[0] = p1[0] - p[0];
  v[1] = p1[1] - p[1];
  v[2] = p1[2] - p[2];  
  double dv = sqrt ( _sqr(v[0]) + _sqr(v[1]) + _sqr(v[2]) );
  v[0] = v[0] / dv;
  v[1] = v[1] / dv;
  v[2] = v[2] / dv;
  
  ANNcoord u[3];
  u[0] = p2[0] - p[0];
  u[1] = p2[1] - p[1];
  u[2] = p2[2] - p[2];
  double du = sqrt ( _sqr(u[0]) + _sqr(u[1]) + _sqr(u[2]) );
  u[0] = u[0] / du;
  u[1] = u[1] / du;
  u[2] = u[2] / du;
  
  /// grid plane ///
  for (double v_step = res ; v_step <= dv/*-res*/ ; v_step = v_step + res)
  {
    for (double u_step = res ; u_step <= du/*-res*/ ; u_step = u_step + res)
    {
      ANNpoint point = annAllocPt (3);
      point[0] = p[0] + v_step*v[0] + u_step*u[0];
      point[1] = p[1] + v_step*v[1] + u_step*u[1];
      point[2] = p[2] + v_step*v[2] + u_step*u[2];
      
      int k_negative = kd_tree_negative->annkFRSearch (point, sqr_negative_thresh, 0, NULL, NULL, 0.0);
      if ( k_negative == 0 )
      {
        all_negative.push_back (point);
      }
      all_grids.push_back (point);
    }
  }
}

void Line2Box (ANNpointArray points, shape line, vector<ANNpoint> &all_grids, vector<ANNpoint> &all_negative, ANNkd_tree* kd_tree_negative, double sqr_negative_thresh, double minZ, double maxZ, double edges[4][3], 
               bool compute_negatives=true)
{
  /// compute line vector ///
  double l[3];
  l[0] = line.model[3] - line.model[0];
  l[1] = line.model[4] - line.model[1];
  l[2] = 0.0;
  double nl = sqrt ( _sqr(l[0]) + _sqr(l[1]) + _sqr(l[2]) );
  l[0] = l[0] / nl;
  l[1] = l[1] / nl;
  l[2] = l[2] / nl;
  
  double n[3];
  n[0] = 0.0;
  n[1] = 0.0;
  n[2] = 1.0;
  
  double m[3];
  m[0] = l[1]*n[2] - l[2]*n[1];
  m[1] = l[2]*n[0] - l[0]*n[2];
  m[2] = l[0]*n[1] - l[1]*n[0];
  
  /// get inliers limits lenghtwise and crosswise ///
  double minDistLW =  DBL_MAX;
  double maxDistLW = -DBL_MAX;
  double minDistCW =  DBL_MAX;
  double maxDistCW = -DBL_MAX;
  for ( int i=0 ; i < (int)line.inliers.size() ; i++ )
  {
    double p[2];
    p[0] = points [line.inliers[i]] [0] - line.model[0];
    p[1] = points [line.inliers[i]] [1] - line.model[1];
    
    double DistLW = (l[0] * p[0]) + (l[1] * p[1]);
    if ( minDistLW > DistLW )  minDistLW = DistLW;
    if ( maxDistLW < DistLW )  maxDistLW = DistLW;
    
    double DistCW = (m[0] * p[0]) + (m[1] * p[1]);
    if ( minDistCW > DistCW )  minDistCW = DistCW;
    if ( maxDistCW < DistCW )  maxDistCW = DistCW;
  }
  
  /// compute plane edges /// generated in circle order ///
  edges[0][0] = line.model[0] + l[0]*minDistLW;      edges[0][1] = line.model[1] + l[1]*minDistLW;      edges[0][2] = minZ;
  edges[1][0] = line.model[0] + l[0]*maxDistLW;      edges[1][1] = line.model[1] + l[1]*maxDistLW;      edges[1][2] = minZ;
  edges[2][0] = line.model[0] + l[0]*maxDistLW;      edges[2][1] = line.model[1] + l[1]*maxDistLW;      edges[2][2] = maxZ;
  edges[3][0] = line.model[0] + l[0]*minDistLW;      edges[3][1] = line.model[1] + l[1]*minDistLW;      edges[3][2] = maxZ;
  
  double width = line_thresh;
  double cuboid[8][3];
        
  width = maxDistCW;
  cuboid[0][0] = edges[0][0] + width*m[0];        cuboid[0][1] = edges[0][1] + width*m[1];        cuboid[0][2] = edges[0][2] + width*m[2];
  cuboid[1][0] = edges[1][0] + width*m[0];        cuboid[1][1] = edges[1][1] + width*m[1];        cuboid[1][2] = edges[1][2] + width*m[2];
  cuboid[2][0] = edges[2][0] + width*m[0];        cuboid[2][1] = edges[2][1] + width*m[1];        cuboid[2][2] = edges[2][2] + width*m[2];
  cuboid[3][0] = edges[3][0] + width*m[0];        cuboid[3][1] = edges[3][1] + width*m[1];        cuboid[3][2] = edges[3][2] + width*m[2];
  
  width = -minDistCW;
  cuboid[4][0] = edges[0][0] - width*m[0];        cuboid[4][1] = edges[0][1] - width*m[1];        cuboid[4][2] = edges[0][2] - width*m[2];
  cuboid[5][0] = edges[1][0] - width*m[0];        cuboid[5][1] = edges[1][1] - width*m[1];        cuboid[5][2] = edges[1][2] - width*m[2];
  cuboid[6][0] = edges[2][0] - width*m[0];        cuboid[6][1] = edges[2][1] - width*m[1];        cuboid[6][2] = edges[2][2] - width*m[2];
  cuboid[7][0] = edges[3][0] - width*m[0];        cuboid[7][1] = edges[3][1] - width*m[1];        cuboid[7][2] = edges[3][2] - width*m[2];
  
  if (compute_negatives)
  {
    /// GRID EDGES OF THE BOX ///
    gridEdges (all_grids, all_negative, cuboid, kd_tree_negative, sqr_negative_thresh);
    
    /// GRID FRAME OF THE BOX ///
    gridLine (all_grids, all_negative, cuboid[0], cuboid[1], kd_tree_negative, sqr_negative_thresh);
    gridLine (all_grids, all_negative, cuboid[1], cuboid[2], kd_tree_negative, sqr_negative_thresh);
    gridLine (all_grids, all_negative, cuboid[2], cuboid[3], kd_tree_negative, sqr_negative_thresh);
    gridLine (all_grids, all_negative, cuboid[3], cuboid[0], kd_tree_negative, sqr_negative_thresh);
        
    gridLine (all_grids, all_negative, cuboid[4], cuboid[5], kd_tree_negative, sqr_negative_thresh);
    gridLine (all_grids, all_negative, cuboid[5], cuboid[6], kd_tree_negative, sqr_negative_thresh);
    gridLine (all_grids, all_negative, cuboid[6], cuboid[7], kd_tree_negative, sqr_negative_thresh);
    gridLine (all_grids, all_negative, cuboid[7], cuboid[4], kd_tree_negative, sqr_negative_thresh);
        
    gridLine (all_grids, all_negative, cuboid[0], cuboid[4], kd_tree_negative, sqr_negative_thresh);
    gridLine (all_grids, all_negative, cuboid[1], cuboid[5], kd_tree_negative, sqr_negative_thresh);
    gridLine (all_grids, all_negative, cuboid[2], cuboid[6], kd_tree_negative, sqr_negative_thresh);
    gridLine (all_grids, all_negative, cuboid[3], cuboid[7], kd_tree_negative, sqr_negative_thresh);
        
    /// GRID PLANES OF THE BOX ///
    gridPlane (all_grids, all_negative, cuboid[0], cuboid[1], cuboid[3], kd_tree_negative, sqr_negative_thresh);
    gridPlane (all_grids, all_negative, cuboid[0], cuboid[3], cuboid[4], kd_tree_negative, sqr_negative_thresh);
    gridPlane (all_grids, all_negative, cuboid[0], cuboid[4], cuboid[1], kd_tree_negative, sqr_negative_thresh);
        
    gridPlane (all_grids, all_negative, cuboid[6], cuboid[7], cuboid[5], kd_tree_negative, sqr_negative_thresh);
    gridPlane (all_grids, all_negative, cuboid[6], cuboid[5], cuboid[2], kd_tree_negative, sqr_negative_thresh);
    gridPlane (all_grids, all_negative, cuboid[6], cuboid[2], cuboid[7], kd_tree_negative, sqr_negative_thresh);
  }
}

void printBox (ANNpointArray points, shape line, double edges[4][3], vtkRenderer* ren, vtkRenderWindowInteractor* iren)
{
  double l[3];
  l[0] = line.model[3] - line.model[0];
  l[1] = line.model[4] - line.model[1];
  l[2] = 0.0;
  double nl = sqrt ( _sqr(l[0]) + _sqr(l[1]) + _sqr(l[2]) );
  l[0] = l[0] / nl;
  l[1] = l[1] / nl;
  l[2] = l[2] / nl;
        
  double n[3];
  n[0] = 0.0;
  n[1] = 0.0;
  n[2] = 1.0;
        
  double m[3];
  m[0] = l[1]*n[2] - l[2]*n[1];
  m[1] = l[2]*n[0] - l[0]*n[2];
  m[2] = l[0]*n[1] - l[1]*n[0];
        
  double width = line_thresh;
  double cuboid[8][3];
        
  /// get perpendicular inliers limits ///
  double minDist =  DBL_MAX;
  double maxDist = -DBL_MAX;
  for (int i=0 ; i < (int)line.inliers.size() ; i++ )
  {
    double p[2];
    p[0] = points [line.inliers[i]] [0] - line.model[0];
    p[1] = points [line.inliers[i]] [1] - line.model[1];
    double Dist = (m[0] * p[0]) + (m[1] * p[1]);
    if ( minDist > Dist )  minDist = Dist;
    if ( maxDist < Dist )  maxDist = Dist;
  }
  
  width = maxDist;
  cuboid[0][0] = edges[0][0] + width*m[0];        cuboid[0][1] = edges[0][1] + width*m[1];        cuboid[0][2] = edges[0][2] + width*m[2];
  cuboid[1][0] = edges[1][0] + width*m[0];        cuboid[1][1] = edges[1][1] + width*m[1];        cuboid[1][2] = edges[1][2] + width*m[2];
  cuboid[2][0] = edges[2][0] + width*m[0];        cuboid[2][1] = edges[2][1] + width*m[1];        cuboid[2][2] = edges[2][2] + width*m[2];
  cuboid[3][0] = edges[3][0] + width*m[0];        cuboid[3][1] = edges[3][1] + width*m[1];        cuboid[3][2] = edges[3][2] + width*m[2];
          
  width = -minDist;
  cuboid[4][0] = edges[0][0] - width*m[0];        cuboid[4][1] = edges[0][1] - width*m[1];        cuboid[4][2] = edges[0][2] - width*m[2];
  cuboid[5][0] = edges[1][0] - width*m[0];        cuboid[5][1] = edges[1][1] - width*m[1];        cuboid[5][2] = edges[1][2] - width*m[2];
  cuboid[6][0] = edges[2][0] - width*m[0];        cuboid[6][1] = edges[2][1] - width*m[1];        cuboid[6][2] = edges[2][2] - width*m[2];
  cuboid[7][0] = edges[3][0] - width*m[0];        cuboid[7][1] = edges[3][1] - width*m[1];        cuboid[7][2] = edges[3][2] - width*m[2];
  
  vtkActor* actor = createVTKCuboid (cuboid[0], cuboid[1], cuboid[2], cuboid[3], cuboid[4], cuboid[5], cuboid[6], cuboid[7]);
  actor->GetProperty()->SetRepresentationToSurface();
  actor->GetProperty()->SetColor (0.0, 0.0, 0.0);
  actor->GetProperty()->SetOpacity ( opacity );
  ren->AddActor (actor);
  
  if (shape_step)
  {
    iren->Render();
    iren->Start();
  }
}

/// TRANSITION FROM CIRCLE TO CYLINDER /// COMPUTE GRID AND NEGATIVE POINTS ///
void Circle2Cylinder (ANNpointArray points, shape circle, vector<ANNpoint> &all_grids, vector<ANNpoint> &all_negative, ANNkd_tree* kd_tree_negative, double sqr_negative_thresh, double minZ, double maxZ)
{
  /// grid surface of cylinder ///
  for (double z = minZ ; z <= maxZ ; z = z + res)
  {
    for (double a = 0.0 ; a <= M_PI*2 - res_ang ; a = a + res_ang)
    {
      ANNpoint p = annAllocPt (3);
      p[0] = circle.model[0] + circle.model[3]*cos(a);
      p[1] = circle.model[1] + circle.model[3]*sin(a);
      p[2] = z;
      
      int k_negative = kd_tree_negative->annkFRSearch (p, sqr_negative_thresh, 0, NULL, NULL, 0.0);
      if ( k_negative == 0 )
      {
        all_negative.push_back (p);
      }
      all_grids.push_back (p);
    }
  }
}

void printCylinder (shape circle, double minZ, double maxZ, double thresh, vtkRenderer* ren, vtkRenderWindowInteractor* iren)
{
  double cx = circle.model[0];
  double cy = circle.model[1];
  double  r = circle.model[3];
  
  /// Inner Cylinder ///
  ANNcoord innerCylinder[7] = {cx, cy, minZ, cx, cy, maxZ, r - thresh};
  vtkActor* innerCylinderActor = createVTKCylinder (innerCylinder);
  innerCylinderActor->GetProperty()->SetRepresentationToSurface();
  innerCylinderActor->GetProperty()->SetColor (0.0, 0.0, 0.0);
  innerCylinderActor->GetProperty()->SetOpacity ( opacity );
  ren->AddActor (innerCylinderActor);
  
  /// Outer Cylinder ///
  ANNcoord outerCylinder[7] = {cx, cy, minZ, cx, cy, maxZ, r + thresh};
  vtkActor* outerCylinderActor = createVTKCylinder (outerCylinder);
  outerCylinderActor->GetProperty()->SetRepresentationToSurface();
  outerCylinderActor->GetProperty()->SetColor (0.0, 0.0, 0.0);
  outerCylinderActor->GetProperty()->SetOpacity ( opacity );
  ren->AddActor (outerCylinderActor);
  
  /// Bottom Cap ///
  vtkLineSource* bottomSweepLine = vtkLineSource::New ();
  bottomSweepLine->SetPoint1 (cx + r - thresh, cy, minZ);
  bottomSweepLine->SetPoint2 (cx + r + thresh, cy, minZ);
  
  vtkRotationFilter* bottomCap = vtkRotationFilter::New ();
  bottomCap->SetInputConnection (bottomSweepLine->GetOutputPort ());
  bottomCap->SetCenter (cx, cy, maxZ);
  bottomCap->SetAngle (0.25);
  bottomCap->SetNumberOfCopies (360*4);
  
  vtkActor* bottomCapActor = createActorFromDataSet (bottomCap->GetOutput (), false);
  bottomCapActor->GetProperty()->SetColor (0.0, 0.0, 0.0);
  bottomCapActor->GetProperty()->SetOpacity ( opacity / 5 );
  ren->AddActor (bottomCapActor);
  
  /// Upper Cap ///
  vtkLineSource* upperSweepLine = vtkLineSource::New ();
  upperSweepLine->SetPoint1 (cx + r - thresh, cy, maxZ);
  upperSweepLine->SetPoint2 (cx + r + thresh, cy, maxZ);
  
  vtkRotationFilter* upperCap = vtkRotationFilter::New ();
  upperCap->SetInputConnection (upperSweepLine->GetOutputPort ());
  upperCap->SetCenter (cx, cy, maxZ);
  upperCap->SetAngle (0.25);
  upperCap->SetNumberOfCopies (360*4);

  vtkActor* upperCapActor = createActorFromDataSet (upperCap->GetOutput (), false);
  upperCapActor->GetProperty()->SetColor (0.0, 0.0, 0.0);
  upperCapActor->GetProperty()->SetOpacity ( opacity / 5 );
  ren->AddActor (upperCapActor);
  
  if ( shape_step )
  {        
    iren->Render();
    iren->Start();
  }
}

/// CREATE ANN POINTS FROM 2D VECTOR OF POINTS ///
ANNpointArray createANNpoints (vector<vector<vector<ANNpoint> > > vect, int &size)
{
  for (int r = 0 ; r < (int)vect.size() ; r++)
    for (int s = 0 ; s < (int)vect[r].size() ; s++)
      size = size + vect[r][s].size();
  
  ANNpointArray points = annAllocPts (size, 3, 0.0);
  
  int n = 0;
  for (int r = 0 ; r < (int)vect.size() ; r++)
  {
    for (int s = 0 ; s < (int)vect[r].size() ; s++)
    {
      for (int i = 0 ; i < (int)vect[r][s].size() ; i++)
      {
        points[n][0] = vect[r][s][i] [0];
        points[n][1] = vect[r][s][i] [1];
        points[n][2] = vect[r][s][i] [2];
        n++;
      }
    }
  }
  size = n;
  
  return points;
}

void checkDuplicate (vector<vector<vector<ANNpoint> > > vect)
{
  fprintf (stderr, "----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n");
  for (int r = 0 ; r < (int)vect.size() ; r++)
    for (int s = 0 ; s < (int)vect[r].size() ; s++)
      for (int i = 0 ; i < (int)vect[r][s].size() ; i++)
        for (int j = i+1 ; j < (int)vect[r][s].size() ; j++)
          if ( i != j )
            if ( (vect[r][s][i][0] == vect[r][s][j][0]) && (vect[r][s][i][1] == vect[r][s][j][1]) && (vect[r][s][i][2] == vect[r][s][j][2]) )
              fprintf (stderr, " duplicate in region %d :  %f %f %f (%d) with %f %f %f (%d) \n", r, vect[r][s][i][0], vect[r][s][i][1], vect[r][s][i][2], i, vect[r][s][j][0], vect[r][s][j][1], vect[r][s][j][2], j);
  fprintf (stderr, "----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n");
}

bool inlier (ANNpoint P1, ANNpoint P2, ANNpoint P0, double sqr_thresh)
{
  ANNcoord P1P2[3];
  P1P2[0] = P2[0] - P1[0];
  P1P2[1] = P2[1] - P1[1];
  P1P2[2] = P2[2] - P1[2];
  
  ANNcoord P0P1[3];
  P0P1[0] = P1[0] - P0[0];
  P0P1[1] = P1[1] - P0[1];
  P0P1[2] = P1[2] - P0[2];
  
  ANNcoord P1P2xP0P1[3];
  P1P2xP0P1[0] = P1P2[1]*P0P1[2] - P1P2[2]*P0P1[1];
  P1P2xP0P1[1] = P1P2[2]*P0P1[0] - P1P2[0]*P0P1[2];
  P1P2xP0P1[2] = P1P2[0]*P0P1[1] - P1P2[1]*P0P1[0];
  
  double normP1P2xP0P1 = _sqr(P1P2xP0P1[0]) + _sqr(P1P2xP0P1[1]) + _sqr(P1P2xP0P1[2]) ;
  double normP1P2 = _sqr(P1P2[0]) + _sqr(P1P2[1]) + _sqr(P1P2[2]) ;
  double sqr_d = normP1P2xP0P1 / normP1P2;
  
  return ( sqr_d < sqr_thresh );
}



void printRegionsOfLayer (ANNpointArray points, vector<vector<int> > regions, vector<int> vector_of_indices, vtkRenderer* ren, vtkRenderWindowInteractor* iren, bool verbose=false)
{
  if ( verbose )
  {
    for ( int reg = 0 ; reg < (int)regions.size() ; reg++)
    {
      double r = 1.0 * ( rand() / (RAND_MAX + 1.0) );
      double g = 1.0 * ( rand() / (RAND_MAX + 1.0) );
      double b = 1.0 * ( rand() / (RAND_MAX + 1.0) );
      ren->AddActor (createActorFromDataSet (ANNToVTK(points, regions[reg]), r, g, b, point_size, false));
    }
    
    iren->Render();
    iren->Start();
    
    for ( int reg = 0 ; reg < (int)regions.size() ; reg++)
    {
      ren->AddActor (createActorFromDataSet (ANNToVTK(points, regions[reg]), 0.5, 0.5, 0.5, point_size, false));
    }
    
    iren->Render();
    iren->Start();
  }
}

void printLayers (ANNpointArray points, vector<vector<int> > layers, vector<int> vector_of_indices, vtkRenderer* ren, vtkRenderWindowInteractor* iren, bool verbose=false)
{
  if ( verbose )
  {
    fprintf (stderr, "\n");
    
    int nr_points = 0;
    for ( int lay = 0 ; lay < (int)layers.size() ; lay++ )
    {
      nr_points = nr_points + (int)layers[lay].size();
      
      fprintf (stderr, " lay %2d has %4d points \n", lay, (int)layers[lay].size());
      double r = 1.0 * ( rand() / (RAND_MAX + 1.0) );
      double g = 1.0 * ( rand() / (RAND_MAX + 1.0) );
      double b = 1.0 * ( rand() / (RAND_MAX + 1.0) );
      ren->AddActor (createActorFromDataSet (ANNToVTK (points, layers[lay]), r, g, b, point_size, false));
      
      iren->Render();
      iren->Start();
    }
    
    ren->AddActor (createActorFromDataSet (ANNToVTK(points, vector_of_indices), 0.5, 0.5, 0.5, point_size, false));
    
    iren->Render();
    iren->Start();
  }
}



int main (int argc, char** argv)
{
  // Declare Timer //
  tictoc grand_timer;
  // Starting Timer //
  grand_timer.tic ();
  
//   srand(time(0));
  
  if (argc < 2)
  {
    print_error (stderr, "Syntax is: <name>.cc <input>.pcd <options>\n");
    fprintf (stderr, "  where options are: -line_thresh X                 = threshold for line inlier selection\n");
    fprintf (stderr, "                     -circle_thresh X               = threshold for circle inlier selection\n");
    fprintf (stderr, "                     -connectivity_thresh X         = connectivity threshold for region segmentation\n");
    fprintf (stderr, "                     -ang_thresh X                  = \n");
    fprintf (stderr, "                     -density_thresh X              = \n");
    fprintf (stderr, "                     -thickness_thresh X            = \n");
//     fprintf (stderr, "                     -angle_merging_thresh X        = \n");
    fprintf (stderr, "                     -line_merging_thresh X         = \n");
    fprintf (stderr, "                     -boundary_thresh X             = \n");
    
    fprintf (stderr, "                     -min_rad X                     = minimum physical radius for objects\n");
    fprintf (stderr, "                     -max_rad X                     = maximum physical radius for objects\n");
    fprintf (stderr, "                     -min_reg_size D                = minimum number of left points in a region\n");
    fprintf (stderr, "                     -min_reg_bound_size D          = \n");
    fprintf (stderr, "                     -min_inliers_line D            = \n");
    fprintf (stderr, "                     -min_inliers_circle D          = \n");
    
    fprintf (stderr, "                     -point_size D                  = \n");
    fprintf (stderr, "                     -res X                         = \n");
    fprintf (stderr, "                     -res_ang X                     = \n");
    fprintf (stderr, "                     -negative_thresh X             = \n");
    fprintf (stderr, "                     -occlusion_thresh X            = \n");
    
    fprintf (stderr, "                     -rectanguloid_approximation X  = \n");
    fprintf (stderr, "                     -neg_per_thresh X              = \n");
    
    fprintf (stderr, "                     -region_step B                 = \n");
    fprintf (stderr, "                     -model_step B                  = \n");
    fprintf (stderr, "                     -shape_step B                  = \n");
    
    fprintf (stderr, "                     -opacity X                     = \n");
    
    fprintf (stderr, "                     -height_of_layer X            = \n");
    print_value (stderr, "\n");
    return (-1);
  }
  
  ParseArgument (argc, argv, "-line_thresh", line_thresh);
  ParseArgument (argc, argv, "-circle_thresh", circle_thresh);
  ParseArgument (argc, argv, "-connectivity_thresh", connectivity_thresh);
  ParseArgument (argc, argv, "-ang_thresh", ang_thresh);
  ParseArgument (argc, argv, "-density_thresh", density_thresh);
  ParseArgument (argc, argv, "-thickness_thresh", thickness_thresh);
//   ParseArgument (argc, argv, "-angle_merging_thresh", angle_merging_thresh);
  ParseArgument (argc, argv, "-line_merging_thresh", line_merging_thresh);
  ParseArgument (argc, argv, "-boundary_thresh", boundary_thresh);
  
  ParseArgument (argc, argv, "-min_nr_nn", min_nr_nn);
  ParseArgument (argc, argv, "-max_nr_nn", max_nr_nn);
  ParseArgument (argc, argv, "-min_rad", min_rad);
  ParseArgument (argc, argv, "-max_rad", max_rad);
  
  ParseArgument (argc, argv, "-min_reg_size", min_reg_size);
  ParseArgument (argc, argv, "-min_reg_bound_size", min_reg_bound_size);
  ParseArgument (argc, argv, "-min_inliers_line", min_inliers_line);
  ParseArgument (argc, argv, "-min_inliers_circle", min_inliers_circle);
  
  ParseArgument (argc, argv, "-point_size", point_size);
  ParseArgument (argc, argv, "-res", res);
  ParseArgument (argc, argv, "-res_ang", res_ang);
  ParseArgument (argc, argv, "-negative_thresh", negative_thresh);
  ParseArgument (argc, argv, "-occlusion_thresh", occlusion_thresh);
  
  ParseArgument (argc, argv, "-rectanguloid_approximation", rectanguloid_approximation);
  ParseArgument (argc, argv, "-neg_per_thresh", neg_per_thresh);
  
  ParseArgument (argc, argv, "-region_step",  region_step);
  ParseArgument (argc, argv, "-model_step",   model_step);
  ParseArgument (argc, argv, "-shape_step",   shape_step);
  
  ParseArgument (argc, argv, "-opacity", opacity);
  
  ParseArgument (argc, argv, "-height_of_layer", height_of_layer);
  
  ang_thresh = DEG2RAD (ang_thresh);
  res_ang = DEG2RAD (res_ang);
//   angle_merging_thresh = DEG2RAD (angle_merging_thresh);
  line_merging_thresh = DEG2RAD (line_merging_thresh);
  
  
  
  // Take only the first .pcd file into account
  vector<int> pPCDFileIndices = ParseFileExtensionArgument (argc, argv, ".pcd");
  if (pPCDFileIndices.size () == 0)
  {
    print_error (stderr, "No .PCD file given as input!\n");
    return (-1);
  }
  
  // Load the points from the .PCD file
  PCD_Header header;
  print_info (stderr, "Loading ");
  print_value (stderr, "%s... ", argv[pPCDFileIndices.at (0)]);
  ANNpointArray points = LoadPCDFile (argv[pPCDFileIndices.at (0)], header);
  if (points == NULL) return (-1);
  fprintf (stderr, "[done: "); print_value (stderr, "%d %d", header.nr_points, header.dimID.size ()); fprintf (stderr, "D points]\n");
  print_info (stderr, "Available dimensions: "); print_value (stderr, "%s\n", getAvailableDimensions (header).c_str ());
  
  // Create vtk stuff
  vtkRenderer* ren = vtkRenderer::New ();
  vtkRenderWindowInteractor* iren = CreateRenderWindowAndInteractor (ren, "LAYERS-STRUCT", argc, argv);
  
  ren->SetBackground (1.0, 1.0, 1.0);
  ren->AddActor (createActorFromDataSet (ANNToVTK(points, header.nr_points), 0.0, 0.0, 0.0, point_size, false));    // color points in black
  iren->Render();
  iren->Start();
  
  /// COMPUTE DENSE POINTS //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
  int kIdx = getIndex (header, "k");
  
  // Initializing KD-Tree 3D //
  ANNkd_tree* kd_tree = new ANNkd_tree (points, header.nr_points, 3, 25);
  ANNidxArray nnIdx = new ANNidx[max_nr_nn];
  ANNdistArray sqrDists = new ANNdist[max_nr_nn];
  
  double sqr_density_thresh = density_thresh * density_thresh;
  vector<int> vector_of_indices = getDensePoints (points, header.nr_points, kIdx, kd_tree, sqr_density_thresh, ren, iren, true);
  
  /// COMPUTE LAYERS ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
  double minZ =  DBL_MAX;
  double maxZ = -DBL_MAX;
  
  int zIdx = getIndex (header, "z");
  for ( int idx = 0 ; idx < (int)vector_of_indices.size() ; idx++ )
  {
    if ( minZ > points [vector_of_indices[idx]] [zIdx] )  minZ = points [vector_of_indices[idx]] [zIdx];
    if ( maxZ < points [vector_of_indices[idx]] [zIdx] )  maxZ = points [vector_of_indices[idx]] [zIdx];
  }
  
  double height_of_points = maxZ - minZ;
    
  int number_of_layers = ceil (height_of_points / height_of_layer);
  
  vector<vector<int> > layers;
  for ( int lay = 0 ; lay < number_of_layers ; lay++ )
  {
    vector<int> layer;
    
    float inferior_limit = minZ + height_of_layer * lay;
    float superior_limit = minZ + height_of_layer * (lay+1);
    
    for ( int idx = 0 ; idx < (int)vector_of_indices.size() ; idx++ )
    {
      if ( ( inferior_limit < points [vector_of_indices[idx]] [zIdx] ) && ( points [vector_of_indices[idx]] [zIdx] <  superior_limit ) )
      {
        layer.push_back (vector_of_indices[idx]);
      }
    }
    
    // sort indices ! necessary for region growing //
    sort (layer.begin(), layer.end());
    
    layers.push_back (layer);
  }
  
  printLayers (points, layers, vector_of_indices, ren, iren, true);
  
  vector<vector<vector<shape> > > shapes;
  
  for ( int lay = 0 ; lay < (int)layers.size() ; lay++ )
  {
    /// COMPUTE REGIONS /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    // create points from indices //
    ANNpointArray points_of_layer = doPointsOfIndices (points, header.nr_points, layers[lay]);
    
    // create KD-Tree of Layer //
    ANNkd_tree* kd_tree_lay = new ANNkd_tree (points_of_layer, header.nr_points, 3, 25);
    ANNidxArray nnIdx_lay = new ANNidx [max_nr_nn];
    ANNdistArray sqrDists_lay = new ANNdist [max_nr_nn];
    
    vector<vector<int> > regions;
    
    double sqr_thresh_connectivity = connectivity_thresh * connectivity_thresh;
    regions = OptimizedRegionSegmentationDistanceBasedNoMarking (points_of_layer, header.nr_points, layers[lay], min_reg_size, kd_tree_lay, nnIdx_lay, sqrDists_lay, max_nr_nn, -1, -1, sqr_thresh_connectivity, false);
    
    fprintf (stderr, " lay %2d has %2d reg \n", lay, (int)regions.size());
    
    printRegionsOfLayer (points, regions, vector_of_indices, ren, iren, false);
    
    /// COMPUTE BOUNDARIES //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
    vector<vector<int> > boundaries = computeBoundaries (points, regions, ang_thresh, ren, iren, true);
  
    /// COMPUTE THICK BOUNDARIES ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
//     double sqr_thickness_thresh = thickness_thresh * thickness_thresh;
    
//     vector<vector<int> > thick_boundaries = computeThickBoundaries (points, regions, boundaries, kIdx, kd_tree, nnIdx, sqrDists, sqr_thickness_thresh, ren, iren, true);
  
    vector<vector<int> > thick_boundaries = boundaries;
    
    /// COMPUTE QUADRILATERAL APPROXIMATION  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    smallestRectangle (points, regions, ren, iren, false);
    
    vector<double> magic_value = computePCA (points, regions, boundaries, ren, iren, false);
    
    vector<double> lama_value = LaimLama (points, regions, boundaries, thick_boundaries, ren, iren, false);
  
    /// Print Quadrilateral Approximation ///
    if ( rectanguloid_approximation == 0.0 )
    {
      fprintf (stderr, "\n  rectanguloid approximation = %f \n\n", rectanguloid_approximation);
    }
    else
    {
      fprintf (stderr, "\n  rectanguloid approximation = %f \n\n", rectanguloid_approximation);
    
      for ( int reg=0 ; reg < (int)regions.size() ; reg++ )
      {
        if ( magic_value[reg] < rectanguloid_approximation )
        {
          print_error (stderr, "    magic[%2d]=%f  \n", reg, magic_value[reg]);
        }
        else
        {
          fprintf (stderr, "    magic[%2d]=%f  vs", reg, magic_value[reg]);
        
          if ( lama_value[reg] < rectanguloid_approximation )
          {
            magic_value[reg] = lama_value[reg];
            print_error (stderr, "  lama[%2d]=%f  \n", reg, lama_value[reg]);
          }
          else
          {
            fprintf (stderr, "  lama[%2d]=%f  \n", reg, lama_value[reg]);
          }
        }
      }
    
      fprintf (stderr, "\n");
    }
  
    /// GET SHAPES OF REGIONS ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
    vector<vector<shape> > all_shapes = getShapes (points, header, regions, boundaries, thick_boundaries, magic_value, kIdx, kd_tree, nnIdx, sqrDists, ren, iren);
    
    /// MERGE SHAPES FROM DIFFERENT REGIONS /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
    mergeRegions (points, regions, thick_boundaries, all_shapes, ren, iren);
    
    /// COMPUTE NEGATIVE POINTS FOR SHAPES //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
    // Initialize Negative KD-TREE //
    ANNkd_tree* kd_tree_negative = new ANNkd_tree (points, header.nr_points, 3, 25);
    double sqr_negative_thresh = _sqr(negative_thresh);
  
    vector<vector<vector<ANNpoint> > >    all_grids (all_shapes.size());
    vector<vector<vector<ANNpoint> > > all_negative (all_shapes.size());
  
    /// DEAL WITH SHAPES ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    for (int reg=0 ; reg < (int)all_shapes.size() ; reg++)
    {
      all_grids[reg].resize (all_shapes[reg].size());
      all_negative[reg].resize (all_shapes[reg].size());
    
      for (int sh=0 ; sh < (int)all_shapes[reg].size() ; sh++)
      {
        /// get min and max z coord from model inliers ///
        double minZ =  DBL_MAX;
        double maxZ = -DBL_MAX;
        for (int idx=0 ; idx < (int)all_shapes[reg][sh].inliers.size() ; idx++ )
        {
          if ( minZ > points [all_shapes[reg][sh].inliers[idx]] [2] ) minZ = points [all_shapes[reg][sh].inliers[idx]] [2];
          if ( maxZ < points [all_shapes[reg][sh].inliers[idx]] [2] ) maxZ = points [all_shapes[reg][sh].inliers[idx]] [2];
        }
      
        if (all_shapes[reg][sh].type == 0)
        {
          double edges[4][3];
          Line2Box (points, all_shapes[reg][sh], all_grids[reg][sh], all_negative[reg][sh], kd_tree_negative, sqr_negative_thresh, minZ, maxZ, edges);
          printBox (points, all_shapes[reg][sh], edges, ren, iren);
        }
      
        if (all_shapes[reg][sh].type == 1)
        {
          Circle2Cylinder (points, all_shapes[reg][sh], all_grids[reg][sh], all_negative[reg][sh], kd_tree_negative, sqr_negative_thresh, minZ, maxZ);
          printCylinder (all_shapes[reg][sh], minZ, maxZ, circle_thresh, ren, iren);
        }
      }
    }
    
    shapes.push_back (all_shapes);
  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  /// PRINT THE SHAPES ONLY /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
  vtkRenderer* new_ren = vtkRenderer::New ();
  new_ren->SetBackground (1.0, 1.0, 1.0);
  vtkRenderWindowInteractor* new_iren = CreateRenderWindowAndInteractor (new_ren, "ALL SHAPES ONLY", argc, argv);
  
  for (int lay=0 ; lay < (int)shapes.size() ; lay++)
  {
    // Initialize Negative KD-TREE //
    ANNkd_tree* kd_tree_negative = new ANNkd_tree (points, header.nr_points, 3, 25);
    double sqr_negative_thresh = _sqr(negative_thresh);
  
    vector<vector<vector<ANNpoint> > >    all_grids (shapes[lay].size());
    vector<vector<vector<ANNpoint> > > all_negative (shapes[lay].size());
    
    for (int reg=0 ; reg < (int)shapes[lay].size() ; reg++)
    {
      all_grids[reg].resize (shapes[lay][reg].size());
      all_negative[reg].resize (shapes[lay][reg].size());
      
      for (int shp=0 ; shp < (int)shapes[lay][reg].size() ; shp++)
      {
        /// get min and max z coord from model inliers ///
        double minZ =  DBL_MAX;
        double maxZ = -DBL_MAX;
        for (int idx=0 ; idx < (int)shapes[lay][reg][shp].inliers.size() ; idx++ )
        {
          if ( minZ > points [shapes[lay][reg][shp].inliers[idx]] [2] ) minZ = points [shapes[lay][reg][shp].inliers[idx]] [2];
          if ( maxZ < points [shapes[lay][reg][shp].inliers[idx]] [2] ) maxZ = points [shapes[lay][reg][shp].inliers[idx]] [2];
        }
        
        if (shapes[lay][reg][shp].type == 0)
        {
          double edges[4][3];
          Line2Box (points, shapes[lay][reg][shp], all_grids[reg][shp], all_negative[reg][shp], kd_tree_negative, sqr_negative_thresh, minZ, maxZ, edges);
          printBox (points, shapes[lay][reg][shp], edges, new_ren, new_iren);
        }
        
        if (shapes[lay][reg][shp].type == 1)
        {
          Circle2Cylinder (points, shapes[lay][reg][shp], all_grids[reg][shp], all_negative[reg][shp], kd_tree_negative, sqr_negative_thresh, minZ, maxZ);
          printCylinder (shapes[lay][reg][shp], minZ, maxZ, circle_thresh, new_ren, new_iren);
        }
      }
    }
    
    /// CHECK NEGATIVE POINTS ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
    int vxIdx = getIndex (header, "vx");
    int vyIdx = getIndex (header, "vy");
    int vzIdx = getIndex (header, "vz");
  
    ANNpoint VP = annAllocPt (3);
    VP[0] = points [0] [vxIdx];
    VP[1] = points [0] [vyIdx];
    VP[2] = points [0] [vzIdx];
  
    double search_radius = occlusion_thresh /* - negative_thresh*/ ;
    double sqr_search_radius = search_radius * search_radius;
  
    vector<vector<vector<ANNpoint> > > kept_negative (all_negative.size());
  
    for (int r = 0 ; r < (int)all_negative.size() ; r++)
    {
      kept_negative[r].resize (all_negative[r].size());
    
      for (int s = 0 ; s < (int)all_negative[r].size() ; s++)
      {
        for (int i = 0 ; i < (int)all_negative[r][s].size() ; i++)
        {
          ANNpoint N = annAllocPt (3);
          N[0] = all_negative[r][s][i] [0];
          N[1] = all_negative[r][s][i] [1];
          N[2] = all_negative[r][s][i] [2];
        
          ANNcoord direction[3];
          direction[0] = N[0] - VP[0];
          direction[1] = N[1] - VP[1];
          direction[2] = N[2] - VP[2];
        
          double normalize = sqrt ( _sqr(direction[0]) + _sqr(direction[1]) + _sqr(direction[2]) );
          direction[0] = direction[0] / normalize;
          direction[1] = direction[1] / normalize;
          direction[2] = direction[2] / normalize;
        
          ANNpoint O = annAllocPt (3);
          O[0] = N[0] + occlusion_thresh * direction[0];
          O[1] = N[1] + occlusion_thresh * direction[1];
          O[2] = N[2] + occlusion_thresh * direction[2];
        
          int k = kd_tree->annkFRSearch (O, sqr_search_radius, 0, NULL, NULL, 0.0);
          kd_tree->annkFRSearch (O, sqr_search_radius, k, nnIdx, sqrDists, 0.0);
        
          bool to_keep = true;
          for ( int j = 0 ; j < k ; j++)
          {
            if ( inlier (VP, N, points [nnIdx[j]], sqr_negative_thresh) )
            {
              to_keep = false;
              break;
            }
          }
        
          if ( to_keep )
            kept_negative[r][s].push_back (N);
        
        }
      }
    }
    
    /// COMPUTE FINAL NEGATIVE POINTS ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
    vector<vector<vector<ANNpoint> > > final_kept_negative (kept_negative.size());
  
    for (int r = 0 ; r < (int)kept_negative.size() ; r++)
    {
      final_kept_negative[r].resize (kept_negative[r].size());
    
      for (int s = 0 ; s < (int)kept_negative[r].size() ; s++)
      {
        for (int i = 0 ; i < (int)kept_negative[r][s].size() ; i++)
        {
          ANNpoint KN = annAllocPt (3);
          KN[0] = kept_negative[r][s][i] [0];
          KN[1] = kept_negative[r][s][i] [1];
          KN[2] = kept_negative[r][s][i] [2];
        
          double sqr_dist_VP_KN = _sqr (VP[0]-KN[0]) + _sqr (VP[1]-KN[1]) + _sqr (VP[2]-KN[2]);
        
          int nr_occluding = 0;
          for ( int p = 0 ; p < header.nr_points ; p++)
          {
            double sqr_dist_VP_P = _sqr (VP[0]- points[p][0]) + _sqr (VP[1]- points[p][1]) + _sqr (VP[2]- points[p][2]);
          
            if ( (sqr_dist_VP_P < sqr_dist_VP_KN) && (inlier(VP, KN, points[p], sqr_negative_thresh)) )
            {
              nr_occluding++;
              if ( nr_occluding > 1 )
                break;
            }
          }
        
          if ( nr_occluding > 1 )
            final_kept_negative[r][s].push_back (KN);
        }
      }
    }
  
// // //     new_iren->Render();
// // //     new_iren->Start();
  
    fprintf (stderr, "\n");
    
    /// create ann points from all grids ///
    int ann_all_grids_size = 0;
    ANNpointArray ann_all_grids = createANNpoints (all_grids, ann_all_grids_size);
    fprintf (stderr, "Print Grid Points ! \n");
    new_ren->AddActor (createActorFromDataSet (ANNToVTK (ann_all_grids, ann_all_grids_size), /*0.0, 1.0, 1.0,*/ /*0.8, 1.0, 0.0,*/ /*1.0, 1.0, 0.0,*/ 1.0, 0.5, 0.0, point_size /*+ 2*/, false)); /// ORANGE
// // //     new_iren->Render();
// // //     new_iren->Start();
  
    /// create ann points from all neagtive ///
    int ann_all_negative_size = 0;
    ANNpointArray ann_all_negative = createANNpoints (all_negative, ann_all_negative_size);
    new_ren->AddActor (createActorFromDataSet (ANNToVTK (ann_all_negative, ann_all_negative_size), /*1.0, 0.5, 0.0,*/ /*0.8, 0.0, 0.8,*/ 0.0, 0.0, 0.0, point_size /*+ 2*/, false)); /// BLACK
    fprintf (stderr, "Print Negative Points ! \n");
// // //     new_iren->Render();
// // //     new_iren->Start();
  
    //  /// create ann points from kept negative ///
//   int ann_kept_negative_size = 0;
//   ANNpointArray ann_kept_negative = createANNpoints (kept_negative, ann_kept_negative_size);
//   ren->AddActor (createActorFromDataSet (ANNToVTK (ann_kept_negative, ann_kept_negative_size), 1.0, 0.0, 1.0, point_size /*+ 2*/, false));
//   fprintf (stderr, "Print Kept Negative Points ! \n");
//   iren->Render();
//   iren->Start();
  
    /// create ann points from kept negative ///
    int ann_final_kept_negative_size = 0;
    ANNpointArray ann_final_kept_negative = createANNpoints (final_kept_negative, ann_final_kept_negative_size);
    new_ren->AddActor (createActorFromDataSet (ANNToVTK (ann_final_kept_negative, ann_final_kept_negative_size), 0.2, 1.0, 0.0, point_size /*+ 2*/, false)); /// GREEN
    fprintf (stderr, "Print Final Kept Negative Points ! \n");
// // //     new_iren->Render();
// // //     new_iren->Start();
    
    //  /// CHECK FOR DUPLICATE POINTS //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  checkDuplicate (all_grids);
  
    /// compute percentage of final negative points out of grid ///
// // //     fprintf (stderr, "\n");
// // //     for (int r = 0 ; r < (int)final_kept_negative.size() ; r++)
// // //     {
// // //       fprintf (stderr, "Region [%2d] : \n", r );
// // //       for (int s = 0 ; s < (int)final_kept_negative[r].size() ; s++)
// // //       {
// // //         double negative_percentage = (double)( all_negative[r][s].size() - final_kept_negative[r][s].size()) / (double)all_grids[r][s].size() ;
// // //         fprintf (stderr, "   Shape [%2d] Type [%d] : %6.2f \n", s, shapes[lay][r][s].type, negative_percentage);
// // //         if (negative_percentage < neg_per_thresh) 
// // //         {
// // //           if (shapes[lay][r][s].type == 1)
// // //           {
// // //             vtkRegularPolygonSource* circle = vtkRegularPolygonSource::New();
// // //             circle->SetCenter(shapes[lay][r][s].model[0], shapes[lay][r][s].model[1], 0);
// // //             circle->SetRadius(shapes[lay][r][s].model[3]);
// // //             circle->SetNumberOfSides(99);
// // //             vtkActor* actor = createActorFromDataSet(circle->GetOutput(), false);
// // //             actor->GetProperty()->SetRepresentationToWireframe();
// // //             actor->GetProperty()->SetColor(1.0, 1.0, 0.0);
// // //             new_ren->AddActor(actor);
// // //             new_iren->Render();
// // //             new_iren->Start();
// // //           }
// // //         }
// // //       }
// // //     }
 
// // //     annDeallocPts (ann_all_grids);
// // //     annDeallocPts (ann_all_negative);
// // // //   annDeallocPts (ann_kept_negative);
// // //     annDeallocPts (ann_final_kept_negative);
  
    /// Displaying Overall Time ///
    fprintf (stderr, "----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------");
    fprintf (stderr, " Finished in %g", grand_timer.toc ()); fprintf (stderr, " [s]\n");
    
    new_iren->Render();
    new_iren->Start();
  }
  
// // //   annDeallocPts (points);
  
  iren->Render();
  iren->Start();
  
 
  
  return 0;
}
